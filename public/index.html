<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>GOOD WORD / BAD WORD</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&display=swap" rel="stylesheet">
  <style>
    /* ---------- Base ---------- */
    :root { --card-bg: rgba(255,255,255,0.95); --card-shadow: 0 15px 40px rgba(0,0,0,0.15); }
    body { font-family: 'Inter', sans-serif; }
    .card {
      backdrop-filter: blur(10px);
      background-color: var(--card-bg);
      box-shadow: var(--card-shadow);
      border: 1px solid rgba(0,0,0,0.05);
      transition: transform 0.2s ease-out, box-shadow 0.2s ease-out;
      position: relative;
      z-index: 10;
    }
    button { transition: transform 0.1s ease, box-shadow 0.1s ease; }
    button:active { transform: scale(0.98); box-shadow: 0 4px 10px rgba(0,0,0,0.2); }
    .version-indicator { position: fixed; bottom: 5px; left: 50%; transform: translateX(-50%); font-size: .75rem; color: #9ca3af; z-index:50; }
    #wordDisplay { font-size: 6rem; white-space: nowrap; overflow:hidden; max-width:100%; box-sizing:border-box; position:relative; z-index:10; }

    /* ---------- Buttons (gradients) ---------- */
    .good-button { background: linear-gradient(145deg,#10b981,#059669); }
    .bad-button { background: linear-gradient(145deg,#ef4444,#dc2626); }
    .not-word-button { background: linear-gradient(145deg,#64748b,#475569); }

    /* ---------- Animations ---------- */
    @keyframes slide-out-left-good { 0% {transform:translateX(0);opacity:1} 100% {transform:translateX(-150%);opacity:0;color:#10b981} }
    @keyframes slide-out-right-bad { 0% {transform:translateX(0);opacity:1} 100% {transform:translateX(150%);opacity:0;color:#ef4444} }
    .word-transition-good { animation: slide-out-left-good 0.7s ease-out forwards; }
    .word-transition-bad { animation: slide-out-right-bad 0.7s ease-out forwards; }

    /* Llama/Cake fades */
    .word-fade-llama { transition: opacity 8s ease-out, transform 8s ease-out; opacity:0 !important; transform:scale(.9) !important; }
    .word-fade-cake { transition: opacity 0.3s ease-out, transform 0.3s ease-out; opacity:0 !important; transform:scale(.95) !important; }

    /* ---------- Theme base adjustments (kept minimal here; theme-specific rules below) ---------- */
    body.theme-default { background: linear-gradient(135deg,#fef2be 0%,#b5def0 100%) !important; }
    .theme-default #gameCard { backdrop-filter: blur(10px); background-color: rgba(255,255,255,0.95); box-shadow: 0 15px 40px rgba(0,0,0,0.15); border: 1px solid rgba(0,0,0,0.05); }

    /* Rainbow (thin frame) */
    @keyframes rotate-border { 0% { background-position:0% 0% } 100% { background-position:100% 100% } }
    @keyframes rainbow-text { 0% { filter: hue-rotate(0deg) } 100% { filter: hue-rotate(360deg) } }

    body.theme-rainbow { background: #f7f7f7 !important; }
    .theme-rainbow .card, .theme-rainbow .ranking-card { background-color: transparent; backdrop-filter:none; box-shadow:none; border:none; position:relative; z-index:10; }
    .theme-rainbow .thin-rainbow-frame { position:relative; background-color:#fff; box-shadow:0 5px 15px rgba(0,0,0,0.1); border-radius:1rem; }
    .theme-rainbow .thin-rainbow-frame::before {
      content:''; position:absolute; inset:-3px; border-radius:1.25rem;
      background: linear-gradient(45deg,#ff0000,#ff7f00,#ffff00,#00ff00,#00ffff,#0000ff,#9400d3,#ff0000);
      background-size:400% 400%; animation: rotate-border 20s linear infinite; z-index:-3;
    }
    .theme-rainbow .thin-rainbow-frame::after { content:''; position:absolute; inset:-1px; border-radius:1.1rem; background:#fff; z-index:-2; }
    .theme-rainbow #wordDisplay { background: linear-gradient(45deg,#ff0000,#ff7f00,#ffff00,#00ff00,#00ffff,#0000ff,#9400d3); -webkit-background-clip:text; -webkit-text-fill-color:transparent; color:transparent !important; animation: rainbow-text 5s linear infinite; padding:0 .5rem; line-height:1; }

    /* Dark */
    body.theme-dark { background: #121212 !important; }
    .theme-dark #gameCard, .theme-dark .card, .theme-dark .ranking-card { background-color: rgba(18,18,18,0.95) !important; box-shadow: 0 15px 40px rgba(0,0,0,0.5) !important; border:none !important; }
    .theme-dark .text-gray-500, .theme-dark .text-gray-600 { color: #9ca3af !important; }

    /* Banana */
    body.theme-banana { background: #f8f4b2 !important; }
    .theme-banana #wordDisplay { color: #ffd200; animation: bounce-word .5s ease-out infinite alternate; }
    @keyframes bounce-word { from { transform:translateY(0) } to { transform: translateY(-15px) } }

    /* Winter */
    body.theme-winter { background: linear-gradient(135deg,#e0f7fa 0%,#b3e5fc 100%) !important; }
    .theme-winter #wordDisplay { color: #01579b; text-shadow: 0 0 8px rgba(255,255,255,.8); }

    /* Summer */
    body.theme-summer { background: linear-gradient(135deg,#FFD700 0%,#FFA500 100%) !important; }
    .theme-summer #wordDisplay { color: #FF9800; text-shadow: 0 0 20px #FFF8E1, 0 0 10px #FFEB3B; }

    /* Halloween */
    body.theme-halloween { background: linear-gradient(135deg,#000000 0%,#3a0000 100%) !important; }
    .theme-halloween .card, .theme-halloween .ranking-card { background-color: rgba(10,0,0,0.9) !important; border: 2px solid #FF8C00 !important; box-shadow: 0 0 30px rgba(255,140,0,0.5), 0 15px 40px rgba(0,0,0,0.7) !important; }
    .theme-halloween #wordDisplay { color: #FF8C00; text-shadow: 0 0 20px rgba(255,140,0,1), 0 0 5px rgba(255,140,0,.5); }

    /* Submarine */
    body.theme-submarine { background: linear-gradient(135deg, #020c1e 0%, #0a1931 50%, #183a5a 100%) !important; }
    .theme-submarine #wordDisplay { color: #b0e0e6; text-shadow: 0 0 10px rgba(176,224,230,.7), 0 0 5px rgba(255,255,255,.3); animation: bobbing-word 2.5s ease-in-out infinite; }
    @keyframes bobbing-word { 0% { transform: translateY(0px) rotate(-1deg); } 50% { transform: translateY(-8px) rotate(1deg); } 100% { transform: translateY(0px) rotate(-1deg); } }

    /* Submarine bubbles & winter snow surfaces */
    #snow-effect, #bubble-effect { position: fixed; top:0; left:0; width:100vw; height:100vh; overflow:hidden; z-index:40; pointer-events:none; display:none; }
    body.theme-winter #snow-effect { display:block; }
    body.theme-submarine #bubble-effect { display:block; }

    @media (max-width: 640px) { .rank-item { font-size: .8rem } .vote-counts { font-size: .875rem } }
  </style>
</head>
<body class="flex flex-col items-center justify-center min-h-screen p-4 theme-default">

  <!-- Visual / header -->
  <div id="snow-effect"></div>
  <div id="bubble-effect"></div>

  <header class="text-center mb-8 w-full max-w-lg">
    <div id="logoArea" class="h-32 w-full flex items-center justify-center mb-4 relative">
      <div id="leftBadgeContainer" class="absolute left-0 top-1/2 transform -translate-y-1/2 flex flex-col items-start space-y-1 pl-4">
        <div id="cakeBadge" class="p-2 cursor-pointer text-3xl hidden transition duration-300 hover:scale-110" title="The cake is a lie! Click to go back to the word.">üéÇ</div>
        <div id="llamaBadge" class="p-2 text-3xl hidden transition duration-300 hover:scale-110" title="The Llama has vanished! Click to find the Llama word.">ü¶ô</div>
      </div>

      <img src="logo.png" alt="Good Word / Bad Word Logo" class="h-full w-auto max-w-full"/>

      <div id="rightBadgeContainer" class="absolute right-0 top-1/2 transform -translate-y-1/2 flex flex-col items-end space-y-1 pr-4">
        <div id="contributorBadge" class="p-2 cursor-help text-3xl hidden transition duration-300 hover:scale-110" title="Contributor Badge (0 Submissions)"></div>
        <div id="awardBadge" class="p-2 cursor-help text-3xl transition duration-300 hover:scale-110"></div>
      </div>
    </div>

    <div class="mt-4 flex justify-around p-3 rounded-t-xl bg-white shadow-md vote-counts">
      <div id="goodTotal" class="text-xl font-bold text-green-600">GOOD: 0</div>
      <div id="badTotal" class="text-xl font-bold text-red-600">BAD: 0</div>
    </div>
    <div class="flex justify-center p-2 rounded-b-xl bg-gray-50 shadow-md">
      <div id="wordCount" class="text-sm font-semibold text-gray-500">Words in Database: 0</div>
    </div>
  </header>

  <!-- Game card -->
  <main id="gameCard" class="card p-8 w-full max-w-sm flex flex-col items-center rounded-2xl">
    <div id="wordFrame" class="w-full text-center rounded-xl mb-8 relative">
      <div id="wordDisplay" class="font-extrabold text-gray-900 text-center min-h-[72px]">Loading...</div>
    </div>

    <div class="flex space-x-4 w-full mb-3">
      <button id="goodButton" class="good-button flex-1 py-4 text-white text-lg font-bold rounded-xl shadow-lg hover:shadow-xl focus:outline-none focus:ring-4 focus:ring-green-500/50" disabled>Good Word</button>
      <button id="badButton" class="bad-button flex-1 py-4 text-white text-lg font-bold rounded-xl shadow-lg hover:shadow-xl focus:outline-none focus:ring-4 focus:ring-red-500/50" disabled>Bad Word</button>
    </div>
    <button id="notWordButton" class="not-word-button w-full py-3 text-white text-lg font-bold rounded-xl shadow-lg hover:shadow-xl focus:outline-none focus:ring-4 focus:ring-slate-500/50" disabled>Not a word!</button>
    <button id="customWordButton" class="mt-4 text-sm text-gray-600 hover:text-gray-900 transition duration-150">Submit Custom Word</button>
  </main>

  <div id="postVoteMessage" class="mt-4 w-full max-w-sm text-center text-sm font-medium text-gray-600 min-h-[1.5rem]"></div>

  <!-- Rankings -->
  <section class="mt-8 w-full max-w-4xl grid grid-cols-1 md:grid-cols-2 gap-8">
    <div class="ranking-card card p-6 rounded-xl">
      <h2 class="text-xl font-bold text-green-700 mb-4 border-b pb-2">Top Good Words</h2>
      <div class="ranking-frame thin-rainbow-frame rounded-xl">
        <div id="goodRankings" class="space-y-2"><p class="text-gray-500">No data yet.</p></div>
      </div>
    </div>

    <div class="ranking-card card p-6 rounded-xl">
      <h2 class="text-xl font-bold text-red-700 mb-4 border-b pb-2">Top Bad Words</h2>
      <div class="ranking-frame thin-rainbow-frame rounded-xl">
        <div id="badRankings" class="space-y-2"><p class="text-gray-500">No data yet.</p></div>
      </div>
    </div>
  </section>

  <div class="mt-6 w-full max-w-4xl text-center">
    <button id="showTop100Button" class="px-6 py-2 bg-blue-600 text-white font-bold rounded-lg shadow-md hover:bg-blue-700 transition duration-150">Show Top 100 Rankings</button>
    <button id="compareWordsButton" class="mt-4 px-6 py-2 bg-purple-600 text-white font-bold rounded-lg shadow-md hover:bg-purple-700 transition duration-150">Compare Any Two Words</button>
  </div>

  <!-- Themes + settings -->
  <div class="mt-6 p-4 bg-white/70 rounded-xl w-full max-w-sm flex flex-col items-center shadow-lg border border-gray-100">
    <h3 class="text-lg font-bold text-gray-700 mb-2">Unlocked Themes üé®</h3>
    <select id="themeChooser" class="w-full p-2 border border-gray-300 rounded-lg focus:ring-indigo-500 focus:border-indigo-500 font-semibold">
      <option value="default">Default</option>
    </select>
    <p id="themeUnlockHint" class="text-xs text-gray-500 mt-2">Vote on special words to unlock new themes!</p>

    <button id="showSettingsButton" class="mt-4 px-4 py-2 w-full bg-slate-200 text-gray-700 font-bold rounded-lg shadow-md hover:bg-slate-300 transition duration-150 text-sm">‚öôÔ∏è Settings</button>
  </div>

  <!-- Modals (submission, full rankings, definition, compare, settings) -->
  <div id="submissionModal" class="fixed inset-0 bg-gray-900 bg-opacity-75 hidden items-center justify-center p-4 z-50">
    <div class="bg-white p-6 rounded-xl w-full max-w-md shadow-2xl">
      <h2 class="text-2xl font-bold mb-4">Submit a New Word</h2>
      <input type="text" id="newWordInput" placeholder="Enter your word here..." class="w-full p-3 border border-gray-300 rounded-lg mb-4 focus:ring-2 focus:ring-indigo-500">
      <div id="modalMessage" class="text-sm text-red-500 mb-4"></div>
      <div class="flex justify-end space-x-3">
        <button id="cancelSubmitButton" class="px-4 py-2 bg-gray-200 text-gray-700 font-medium rounded-lg hover:bg-gray-300 transition">Cancel</button>
        <button id="submitWordButton" class="px-4 py-2 bg-indigo-600 text-white font-medium rounded-lg hover:bg-indigo-700 transition">Submit Word</button>
      </div>
    </div>
  </div>

  <div id="fullRankingsModalContainer" class="fixed inset-0 bg-gray-900 bg-opacity-75 hidden items-center justify-center p-4 z-50">
    <div id="fullRankingsModal" class="bg-white p-6 rounded-xl w-full max-w-6xl max-h-[90vh] shadow-2xl flex flex-col">
      <div class="flex justify-between items-center mb-4 border-b pb-2">
        <h2 class="text-2xl font-bold">Top 100 Word Rankings</h2>
        <button id="closeFullRankingsModal" class="text-gray-500 hover:text-gray-800 text-2xl font-bold leading-none">&times;</button>
      </div>
      <div class="flex-grow overflow-y-auto">
        <div class="grid grid-cols-1 lg:grid-cols-2 gap-8">
          <div class="bg-green-50/50 p-4 rounded-lg shadow-inner flex flex-col">
            <h3 class="text-xl font-semibold mb-4 text-green-700">Top 100 Good Words</h3>
            <div id="fullGoodRankings" class="space-y-1"></div>
          </div>
          <div class="bg-red-50/50 p-4 rounded-lg shadow-inner flex flex-col">
            <h3 class="text-xl font-semibold mb-4 text-red-700">Top 100 Bad Words</h3>
            <div id="fullBadRankings" class="space-y-1"></div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <div id="definitionModalContainer" class="fixed inset-0 bg-gray-900 bg-opacity-75 hidden items-center justify-center p-4 z-50">
    <div id="definitionModal" class="bg-white p-6 rounded-xl w-full max-w-lg shadow-2xl flex flex-col max-h-[80vh]">
      <div class="flex justify-between items-center mb-4 border-b pb-2">
        <h2 id="definitionWord" class="text-2xl font-bold">DEFINITION</h2>
        <button id="closeDefinitionModal" class="text-gray-500 hover:text-gray-800 text-2xl font-bold leading-none">&times;</button>
      </div>
      <div id="definitionResults" class="space-y-4 overflow-y-auto"><p>Loading definition...</p></div>
    </div>
  </div>

  <div id="compareModalContainer" class="fixed inset-0 bg-gray-900 bg-opacity-75 hidden items-center justify-center p-4 z-50">
    <div id="compareModal" class="bg-white p-6 rounded-xl w-full max-w-lg shadow-2xl">
      <div class="flex justify-between items-center mb-4 border-b pb-2">
        <h2 class="text-2xl font-bold">Compare Any Two Words</h2>
        <button id="closeCompareModal" class="text-gray-500 hover:text-gray-800 text-2xl font-bold leading-none">&times;</button>
      </div>
      <div class="space-y-4">
        <input type="text" id="wordOneInput" placeholder="Enter first word..." class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-purple-500">
        <input type="text" id="wordTwoInput" placeholder="Enter second word..." class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-purple-500">
        <div id="compareResults" class="p-3 bg-gray-50 rounded-lg min-h-[50px]">Type words above to compare them!</div>
      </div>
      <div class="flex justify-end space-x-3 mt-4">
        <button id="runComparisonButton" class="px-4 py-2 bg-purple-600 text-white font-medium rounded-lg hover:bg-purple-700 transition">Compare</button>
      </div>
    </div>
  </div>

  <div id="settingsModalContainer" class="fixed inset-0 bg-gray-900 bg-opacity-75 hidden items-center justify-center p-4 z-50">
    <div id="settingsModal" class="bg-white p-6 rounded-xl w-full max-w-md shadow-2xl">
      <div class="flex justify-between items-center mb-4 border-b pb-2">
        <h2 class="text-2xl font-bold">User Settings</h2>
        <button id="closeSettingsModal" class="text-gray-500 hover:text-gray-800 text-2xl font-bold leading-none">&times;</button>
      </div>
      <div class="space-y-4">
        <div class="flex items-center justify-between">
          <label for="togglePercentages" class="text-lg font-medium text-gray-700">Show Vote Percentages</label>
          <input type="checkbox" id="togglePercentages" class="h-6 w-6 text-indigo-600 border-gray-300 rounded focus:ring-indigo-500">
        </div>
        <div class="flex items-center justify-between">
          <label for="toggleTips" class="text-lg font-medium text-gray-700">Show Tips & Hints</label>
          <input type="checkbox" id="toggleTips" class="h-6 w-6 text-indigo-600 border-gray-300 rounded focus:ring-indigo-500">
        </div>
      </div>
      <div class="mt-6 border-t pt-4">
        <p class="text-sm text-gray-500">You can also clear all local data (votes, awards, themes, streaks) below. This action is irreversible.</p>
        <button id="clearAllDataButton" class="mt-3 px-4 py-2 w-full bg-red-500 text-white font-medium rounded-lg shadow-md hover:bg-red-600 transition">Clear All Local Data</button>
      </div>
    </div>
  </div>

  <div class="version-indicator">v4.3.1 | Made by Gilxs in 12,025</div>

  <!-- ---------- JavaScript (cleaned & refactored) ---------- -->
  <script>
  (function () {
    'use strict';

    // ------ Configuration / constants ------
    const API_BASE_URL = '/api/words';
    const APP_VERSION = '4.3.1';

    const BOOSTED_WORD = 'CAKE';
    const LLAMA_WORD = 'LLAMA';
    const BOOST_FACTOR = 2.0;
    const CAKE_PROBABILITY = 0.005;
    const LLAMA_PROBABILITY = 0.005;
    const CONTRIBUTION_THRESHOLD = 5;

    const CAKE_WORD_FADE_DURATION = 300; // ms
    const CAKE_MESSAGE_DURATION = 3000; // ms

    const TIPS = [
      "Tip: You can now cast a vote by swiping! Swipe left for GOOD and right for BAD.",
      "Tip: Have you tried comparing words yet? Use the 'Compare Any Two Words' button!",
      "Tip: Tap the word on the card to see its definition!",
      "Tip: Check out the theme chooser below to unlock new styles."
    ];
    const TIP_COOLDOWN = 4;

    const MASH_LIMIT = 10;
    const COOLDOWN_SECONDS = 10;
    const STREAK_WINDOW_MS = 1500;
    const SWIPE_THRESHOLD = 50;

    // ------ App state ------
    let allWords = [];
    let currentWordIndex = -1;
    let userId = localStorage.getItem('userId') || null;
    let voteCount = parseInt(localStorage.getItem('voteCount') || '0', 10);
    let contributorCount = parseInt(localStorage.getItem('contributorCount') || '0', 10);
    let unlockedThemes = JSON.parse(localStorage.getItem('unlockedThemes') || '[]');

    let cakeBadgeUnlocked = localStorage.getItem('cakeBadgeUnlocked') === 'true';
    let llamaBadgeUnlocked = localStorage.getItem('llamaBadgeUnlocked') === 'true';
    let userSettings = JSON.parse(localStorage.getItem('userSettings') || JSON.stringify({ showTips: true, showPercentages: true }));

    // Cooldown / mash detection
    let voteStreak = 0;
    let lastVoteTime = 0;
    let isCoolingDown = false;
    let cooldownEndTime = 0;
    let voteCounterForTips = parseInt(localStorage.getItem('voteCounterForTips') || '0', 10);

    // Swipe tracking
    let startX = 0, startY = 0;

    // Theme words
    const THEME_WORDS = {
      rainbow: 'RAINBOW|GAY|SPARKLE|COLOUR|PRIDE|UNICORN|PROUD|GLITTER|LESBIAN|TINSEL'.split('|'),
      dark: 'THGINDIM!KCALB!EDAHS!HTOG!WODAHS!AJNIN!KRAD!THGIN!HTLAETS'.split('!').map(s => s.split('').reverse().join('')),
      banana: 'BANANA|BANANAS|PLANTAIN|YELLOW|SPLIT|MONKEY|HAMMOCK'.split('|'),
      winter: 'SNOWMAN|SNOW|ICE|WINTER|FROZEN|CHILL|COLD|FLAKE|BLIZZARD|ICICLE|SLEIGH|SNOWBALL|SCARF|JACKET|SLEDGE|NOVEMBER|DECEMBER|JANUARY|JINGLE'.split('|'),
      summer: 'SUMMER|HOT|BEACH|HOLIDAY|SUN|VACATION|SWIM|SAND|POOL|JULY|AUGUST|JUNE'.split('|'),
      halloween: 'HALLOWEEN|GHOST|PUMPKIN|SPIDER|SWEETS|COSTUME|SPOOKY|OCTOBER|WITCH|VAMPIRE|ZOMBIE|BAT|MONSTER'.split('|'),
      submarine: 'SUBMARINE|WATER|WAVES|PLYMOUTH|BRIXHAM|PIRATE|SEA|AQUATIC|AQUA|DEEP|OCTOPUS'.split('|')
    };

    // ------ DOM Elements ------
    const wordFrame = document.getElementById('wordFrame');
    const wordDisplay = document.getElementById('wordDisplay');
    const goodButton = document.getElementById('goodButton');
    const badButton = document.getElementById('badButton');
    const notWordButton = document.getElementById('notWordButton');
    const gameCard = document.getElementById('gameCard');
    const goodTotal = document.getElementById('goodTotal');
    const badTotal = document.getElementById('badTotal');
    const wordCount = document.getElementById('wordCount');
    const goodRankingsDiv = document.getElementById('goodRankings');
    const badRankingsDiv = document.getElementById('badRankings');
    const submissionModal = document.getElementById('submissionModal');
    const newWordInput = document.getElementById('newWordInput');
    const modalMessage = document.getElementById('modalMessage');
    const submitWordButton = document.getElementById('submitWordButton');
    const cancelSubmitButton = document.getElementById('cancelSubmitButton');
    const customWordButton = document.getElementById('customWordButton');
    const versionIndicator = document.querySelector('.version-indicator');
    const awardBadge = document.getElementById('awardBadge');
    const cakeBadge = document.getElementById('cakeBadge');
    const llamaBadge = document.getElementById('llamaBadge');
    const contributorBadge = document.getElementById('contributorBadge');
    const showTop100Button = document.getElementById('showTop100Button');
    const fullRankingsModalContainer = document.getElementById('fullRankingsModalContainer');
    const closeFullRankingsModal = document.getElementById('closeFullRankingsModal');
    const fullGoodRankingsDiv = document.getElementById('fullGoodRankings');
    const fullBadRankingsDiv = document.getElementById('fullBadRankings');
    const themeChooser = document.getElementById('themeChooser');
    const themeUnlockHint = document.getElementById('themeUnlockHint');
    const snowEffect = document.getElementById('snow-effect');
    const bubbleEffect = document.getElementById('bubble-effect');
    const definitionModalContainer = document.getElementById('definitionModalContainer');
    const closeDefinitionModal = document.getElementById('closeDefinitionModal');
    const definitionWord = document.getElementById('definitionWord');
    const definitionResults = document.getElementById('definitionResults');
    const compareWordsButton = document.getElementById('compareWordsButton');
    const compareModalContainer = document.getElementById('compareModalContainer');
    const closeCompareModal = document.getElementById('closeCompareModal');
    const wordOneInput = document.getElementById('wordOneInput');
    const wordTwoInput = document.getElementById('wordTwoInput');
    const compareResults = document.getElementById('compareResults');
    const runComparisonButton = document.getElementById('runComparisonButton');
    const postVoteMessage = document.getElementById('postVoteMessage');
    const showSettingsButton = document.getElementById('showSettingsButton');
    const settingsModalContainer = document.getElementById('settingsModalContainer');
    const closeSettingsModal = document.getElementById('closeSettingsModal');
    const togglePercentages = document.getElementById('togglePercentages');
    const toggleTips = document.getElementById('toggleTips');
    const clearAllDataButton = document.getElementById('clearAllDataButton');

    // current theme state
    let currentTheme = localStorage.getItem('currentTheme') || 'default';

    // ------ Helper utilities ------
    function $(id) { return document.getElementById(id); }

    function safeJsonParse(str, fallback) {
      try { return JSON.parse(str); } catch { return fallback; }
    }

    function setLocal(key, value) {
      try { localStorage.setItem(key, JSON.stringify(value)); } catch (e) { console.warn('localStorage set failed', e); }
    }
    function getLocalParsed(key, fallback) {
      const v = localStorage.getItem(key);
      return v ? safeJsonParse(v, fallback) : fallback;
    }

    function resetWordFrame() {
      wordFrame.style.padding = '';
      wordFrame.style.backgroundColor = '';
    }
    function resetWordDisplayInlineStyles() {
      wordDisplay.style.background = '';
      wordDisplay.style.webkitBackgroundClip = '';
      wordDisplay.style.webkitTextFillColor = '';
      wordDisplay.style.color = '';
      wordDisplay.style.animation = '';
      wordDisplay.style.transform = '';
      wordDisplay.style.textShadow = '';
      wordDisplay.style.opacity = '';
      wordDisplay.style.cursor = '';
      wordDisplay.style.fontSize = '';
      wordDisplay.style.whiteSpace = '';
      wordDisplay.classList.remove('word-fade-llama', 'word-fade-cake', 'word-transition-good', 'word-transition-bad');
    }

    function showMessage(text, isError) {
      resetWordDisplayInlineStyles();
      wordDisplay.textContent = text;
      wordDisplay.className = `text-4xl font-bold text-center min-h-[72px] ${isError ? 'text-red-500' : 'text-gray-500'}`;
      wordDisplay.style.fontSize = '1rem';
      wordDisplay.style.cursor = 'default';
      resetWordFrame();
      goodButton.disabled = badButton.disabled = notWordButton.disabled = true;
      postVoteMessage.textContent = ' ';
    }

    function showCooldownMessage(remaining) {
      showMessage(`Button mashing will not be tolerated. Wait ${remaining}s...`, true);
    }

    // Safe fetch wrapper
    async function safeFetchJson(url, options = {}) {
      const resp = await fetch(url, options);
      const contentType = resp.headers.get('content-type') || '';
      if (!resp.ok) {
        // try parse body
        let body;
        if (contentType.includes('application/json')) {
          try { body = await resp.json(); } catch(e) { body = null; }
        } else {
          try { body = await resp.text(); } catch(e){ body = null; }
        }
        const message = body && body.message ? body.message : `HTTP ${resp.status}`;
        throw new Error(message);
      }
      if (contentType.includes('application/json')) {
        return resp.json();
      } else {
        return resp.text();
      }
    }

    // ------ Theme / UI helpers ------
    function populateThemeChooser() {
      themeChooser.innerHTML = '<option value="default">Default</option>';
      const availableThemes = [...new Set(unlockedThemes || [])].sort();
      availableThemes.forEach(key => {
        const option = document.createElement('option');
        option.value = key;
        option.textContent = key.charAt(0).toUpperCase() + key.slice(1);
        themeChooser.appendChild(option);
      });
      themeChooser.value = currentTheme;
      themeUnlockHint.textContent = availableThemes.length ? `You have ${availableThemes.length} themes unlocked!` : 'Vote on special words to unlock new themes!';
    }

    function toggleEffect(effectEl, active) {
      if (!effectEl) return;
      if (active) effectEl.style.display = '';
      else effectEl.style.display = 'none';
    }

    function applyTheme(theme) {
      // remove old theme classes beginning with theme-
      document.body.className = document.body.className.split(' ').filter(c => !c.startsWith('theme-')).join(' ');
      const themeToApply = theme === 'default' ? 'default' : theme;
      document.body.classList.add(`theme-${themeToApply}`);
      currentTheme = themeToApply;
      localStorage.setItem('currentTheme', currentTheme);

      // effects
      toggleEffect(snowEffect, themeToApply === 'winter');
      toggleEffect(bubbleEffect, themeToApply === 'submarine');

      // card structural adjustments
      if (themeToApply === 'rainbow') {
        gameCard.classList.add('thin-rainbow-frame');
        gameCard.classList.remove('card', 'p-8');
        gameCard.classList.add('p-6');
      } else {
        gameCard.classList.remove('thin-rainbow-frame');
        gameCard.classList.add('card', 'p-8');
        gameCard.classList.remove('p-6');
      }

      displayCurrentWord(allWords[currentWordIndex]);
    }

    function checkAndUnlockThemeForWord(wordText) {
      if (!wordText) return false;
      const upper = wordText.toUpperCase();
      const themeToUnlock = Object.keys(THEME_WORDS).find(k => THEME_WORDS[k].includes(upper));
      if (themeToUnlock && !unlockedThemes.includes(themeToUnlock)) {
        unlockedThemes.push(themeToUnlock);
        setLocal('unlockedThemes', unlockedThemes);
        populateThemeChooser();
        applyTheme(themeToUnlock);
        return true;
      }
      if (themeToUnlock && currentTheme !== themeToUnlock) {
        applyTheme(themeToUnlock);
      }
      return false;
    }

    // ------ Badges / Awards ------
    function updateAwardBadge() {
      let star = 'üò∂', title = `Votes: ${voteCount}. Next Award: Bronze (5 Votes)`;
      if (voteCount >= 250) { star = 'üèÜ'; title = `Platinum Star Award! (${voteCount} Votes)`; }
      else if (voteCount >= 50) { star = 'üåü'; title = `Gold Star Award! (${voteCount} Votes)`; }
      else if (voteCount >= 25) { star = 'ü•à'; title = `Silver Star Award! (${voteCount} Votes)`; }
      else if (voteCount >= 5) { star = 'ü•â'; title = `Bronze Star Award! (${voteCount} Votes)`; }
      awardBadge.textContent = star; awardBadge.title = title;
    }

    function updateContributorBadge() {
      if (contributorCount >= CONTRIBUTION_THRESHOLD) {
        contributorBadge.textContent = '‚úçÔ∏è';
        contributorBadge.title = `Contributor Badge Unlocked! (${contributorCount} Submissions)`;
        contributorBadge.classList.remove('hidden');
      } else {
        contributorBadge.textContent = '';
        contributorBadge.title = `Submissions: ${contributorCount}. Next Badge: Contributor (${CONTRIBUTION_THRESHOLD} Submissions)`;
        contributorBadge.classList.add('hidden');
      }
    }

    function updateSpecialBadges(votedWordText = null, init = false) {
      if (votedWordText) {
        const upperWord = votedWordText.toUpperCase();
        if (upperWord === BOOSTED_WORD) { cakeBadgeUnlocked = true; localStorage.setItem('cakeBadgeUnlocked','true'); }
        if (upperWord === LLAMA_WORD) { llamaBadgeUnlocked = true; localStorage.setItem('llamaBadgeUnlocked','true'); }
      }
      if (cakeBadgeUnlocked) { cakeBadge.classList.remove('hidden'); cakeBadge.classList.add('cursor-pointer'); } else if (init) { cakeBadge.classList.add('hidden'); }
      if (llamaBadgeUnlocked) { llamaBadge.classList.remove('hidden'); llamaBadge.classList.add('cursor-pointer'); } else if (init) { llamaBadge.classList.add('hidden'); }
    }

    // ------ Word selection & display logic ------
    function getWeightedRandomWordIndex(excludeIndex = -1) {
      if (!allWords || allWords.length === 0) return -1;
      if (allWords.length === 1) return 0;

      // fixed-probability special words (if not unlocked)
      const rnd = Math.random();
      let specialWordIndex = -1;
      if (!cakeBadgeUnlocked && rnd < CAKE_PROBABILITY) {
        specialWordIndex = allWords.findIndex(w => w.text.toUpperCase() === BOOSTED_WORD);
      } else if (!llamaBadgeUnlocked && rnd < (CAKE_PROBABILITY + LLAMA_PROBABILITY)) {
        specialWordIndex = allWords.findIndex(w => w.text.toUpperCase() === LLAMA_WORD);
      }
      if (specialWordIndex !== -1 && specialWordIndex !== excludeIndex) return specialWordIndex;

      // fallback weighted selection: words with fewer votes are more likely
      const pool = allWords.map((w, idx) => ({
        idx,
        weight: 1.0 / (((w.goodVotes || 0) + (w.badVotes || 0) + (w.notWordVotes || 0)) + 1)
      })).filter(i => i.idx !== excludeIndex);

      // boost CAKE a bit in weighting
      pool.forEach(p => { if (allWords[p.idx].text.toUpperCase() === BOOSTED_WORD) p.weight *= BOOST_FACTOR; });

      const total = pool.reduce((s,p) => s + p.weight, 0);
      let r = Math.random() * total;
      for (const p of pool) {
        r -= p.weight;
        if (r <= 0) return p.idx;
      }
      return pool[pool.length-1].idx;
    }

    function resizeWordToFit() {
      // compute available width inside card
      const card = gameCard;
      const style = window.getComputedStyle(card);
      const padding = parseFloat(style.paddingLeft) + parseFloat(style.paddingRight);
      const available = card.clientWidth - padding - 24; // some extra safety
      const maxFont = 96;
      wordDisplay.style.whiteSpace = 'nowrap';
      wordDisplay.style.fontSize = maxFont + 'px';
      let scrollW = wordDisplay.scrollWidth;
      let font = maxFont;
      if (scrollW > available) {
        const scale = available / scrollW;
        font = Math.max(24, Math.floor(maxFont * scale));
      }
      wordDisplay.style.fontSize = font + 'px';
      wordDisplay.style.whiteSpace = 'normal';
    }

    function displayCurrentWord(wordObj) {
      if (!wordObj) { showMessage("No words available! Try submitting one.", false); return; }
      resetWordDisplayInlineStyles();
      wordDisplay.textContent = wordObj.text.toUpperCase();
      wordDisplay.className = 'font-extrabold text-gray-900 text-center min-h-[72px]';
      resetWordFrame();
      postVoteMessage.textContent = ' ';

      // theme-specific inline adjustments
      if (currentTheme === 'dark' || currentTheme === 'halloween' || currentTheme === 'submarine') {
        wordDisplay.style.color = '#f3f4f6';
        if (currentTheme === 'halloween') {
          wordDisplay.style.color = '#FF8C00';
          wordDisplay.style.textShadow = '0 0 20px rgba(255,140,0,1), 0 0 5px rgba(255,140,0,0.5)';
        }
        if (currentTheme === 'submarine') {
          wordDisplay.style.color = '#b0e0e6';
          wordDisplay.style.textShadow = '0 0 10px rgba(176,224,230,0.7), 0 0 5px rgba(255,255,255,0.3)';
          wordDisplay.style.animation = 'bobbing-word 2.5s ease-in-out infinite';
        }
      } else if (currentTheme === 'banana') {
        wordDisplay.style.animation = 'bounce-word .5s ease-out infinite alternate';
        wordDisplay.style.color = '#ffd200';
      } else if (currentTheme === 'winter') {
        wordDisplay.style.color = '#01579b';
        wordDisplay.style.textShadow = '0 0 8px rgba(255,255,255,0.8)';
      } else if (currentTheme === 'summer') {
        wordDisplay.style.color = '#FF9800';
        wordDisplay.style.textShadow = '0 0 20px #FFF8E1, 0 0 10px #FFEB3B';
      } else if (currentTheme === 'rainbow') {
        wordDisplay.style.background = 'linear-gradient(45deg,#ff0000,#ff7f00,#ffff00,#00ff00,#00ffff,#0000ff,#9400d3)';
        wordDisplay.style.webkitBackgroundClip = 'text';
        wordDisplay.style.webkitTextFillColor = 'transparent';
        wordDisplay.style.color = 'transparent';
        wordDisplay.style.animation = 'rainbow-text 5s linear infinite';
        wordDisplay.style.padding = '0 .5rem';
      }

      // enable buttons if not cooling down
      if (!isCoolingDown) {
        wordDisplay.style.cursor = 'help';
        goodButton.disabled = badButton.disabled = notWordButton.disabled = false;
      } else {
        goodButton.disabled = badButton.disabled = notWordButton.disabled = true;
      }

      resizeWordToFit();
    }

    // ------ Rankings / Stats ------
    function updateStatsAndRankings() {
      const totalGood = allWords.reduce((s,w) => s + (w.goodVotes || 0), 0);
      const totalBad = allWords.reduce((s,w) => s + (w.badVotes || 0), 0);
      goodTotal.textContent = `GOOD: ${totalGood}`;
      badTotal.textContent = `BAD: ${totalBad}`;
      wordCount.textContent = `Words in Database: ${allWords.length}`;

      // compute ranked arrays
      const ranked = allWords.map(w => ({
        text: w.text,
        good: w.goodVotes || 0,
        bad: w.badVotes || 0,
        score: (w.goodVotes || 0) - (w.badVotes || 0)
      }));
      const topGood = [...ranked].sort((a,b) => (b.score - a.score) || ((b.good + b.bad) - (a.good + a.bad))).slice(0,10);
      const topBad = [...ranked].sort((a,b) => (a.score - b.score) || ((b.good + b.bad) - (a.good + a.bad))).slice(0,10);

      goodRankingsDiv.innerHTML = topGood.length ? topGood.map((r,i) => `<div class="rank-item flex justify-between"><span class="text-gray-900 font-semibold">${i+1}. ${r.text}</span><span class="text-sm text-green-600 font-bold">${r.score} (${r.good}/${r.bad})</span></div>`).join('') : '<p class="text-gray-500">No data yet.</p>';
      badRankingsDiv.innerHTML = topBad.length ? topBad.map((r,i) => `<div class="rank-item flex justify-between"><span class="text-gray-900 font-semibold">${i+1}. ${r.text}</span><span class="text-sm text-red-600 font-bold">${-r.score} (${r.good}/${r.bad})</span></div>`).join('') : '<p class="text-gray-500">No data yet.</p>';
    }

    function getRankedWords(limit=100) {
      const ranked = allWords.map(w => ({ text: w.text, good: w.goodVotes || 0, bad: w.badVotes || 0, score: (w.goodVotes || 0) - (w.badVotes || 0) }));
      const sortedGood = [...ranked].sort((a,b) => (b.score - a.score) || ((b.good + b.bad) - (a.good + a.bad))).slice(0,limit);
      const sortedBad = [...ranked].sort((a,b) => (a.score - b.score) || ((b.good + b.bad) - (a.good + a.bad))).slice(0,limit);
      return { topGood: sortedGood, topBad: sortedBad };
    }

    // ------ Fetch words ------
    async function fetchWords(updateDisplay = true) {
      try {
        if (updateDisplay) showMessage('Loading words.', false);
        const fetched = await safeFetchJson(API_BASE_URL);
        if (!Array.isArray(fetched)) throw new Error('Invalid response from API');
        // filter out heavily flagged words
        const available = fetched.filter(w => (w.notWordVotes || 0) < 3);
        allWords = available;
        wordCount.textContent = `Words in Database: ${fetched.length}`;
        updateStatsAndRankings();
        if (updateDisplay) {
          currentWordIndex = getWeightedRandomWordIndex(-1);
          if (currentWordIndex === -1) showMessage('No words available! Try submitting one.', false);
          else displayCurrentWord(allWords[currentWordIndex]);
        }
      } catch (err) {
        console.error('Error fetching words:', err);
        if (updateDisplay) showMessage('Connection Error. Check your API URL in the script.', true);
      }
    }

    // ------ Voting ------
    function enterCooldown() {
      isCoolingDown = true;
      cooldownEndTime = Date.now() + COOLDOWN_SECONDS * 1000;
      goodButton.disabled = badButton.disabled = notWordButton.disabled = true;
      // show countdown
      const interval = setInterval(() => {
        const remain = Math.ceil((cooldownEndTime - Date.now()) / 1000);
        if (remain <= 0) {
          clearInterval(interval);
          isCoolingDown = false;
          postVoteMessage.textContent = ' ';
          if (allWords[currentWordIndex]) displayCurrentWord(allWords[currentWordIndex]);
        } else {
          showCooldownMessage(remain);
        }
      }, 250);
    }

    async function submitVote(voteType) {
      if (isCoolingDown) {
        const remaining = Math.max(0, Math.ceil((cooldownEndTime - Date.now()) / 1000));
        showCooldownMessage(remaining);
        return;
      }

      const now = Date.now();
      if (lastVoteTime > 0 && (now - lastVoteTime) > STREAK_WINDOW_MS) voteStreak = 1;
      else voteStreak++;
      lastVoteTime = now;

      if (voteStreak > MASH_LIMIT) {
        voteStreak = 0;
        enterCooldown();
        return;
      }

      if (!allWords[currentWordIndex]) return;

      // visual transition
      const transitionDuration = 400;
      try {
        // disable buttons while processing
        goodButton.disabled = badButton.disabled = notWordButton.disabled = true;

        // prepare payload
        const currentWord = allWords[currentWordIndex];
        const payload = { id: currentWord.id, vote: voteType, userId };

        // optimistic local update (for immediate UI)
        // send server request
        const response = await fetch(`${API_BASE_URL}/${currentWord.id}/vote`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        });

        if (!response.ok) {
          const txt = await response.text();
          throw new Error(txt || `Vote failed ${response.status}`);
        }

        // increment local counters safely (will be refreshed on next fetch)
        if (!currentWord[`${voteType}Votes`]) currentWord[`${voteType}Votes`] = 0;
        currentWord[`${voteType}Votes`]++;

        // increment global vote count and awards
        const previousVoteCount = voteCount;
        voteCount++;
        localStorage.setItem('voteCount', voteCount);
        updateAwardBadge();

        // check for theme unlock
        const themeUnlocked = checkAndUnlockThemeForWord(currentWord.text);
        // check for award achieved
        let awardAchieved = false;
        let awardName = '', awardEmoji = '';
        if (previousVoteCount < 5 && voteCount >= 5) { awardAchieved = true; awardName = 'Bronze Star'; awardEmoji = 'ü•â'; }
        else if (previousVoteCount < 25 && voteCount >=25) { awardAchieved = true; awardName = 'Silver Star'; awardEmoji = 'ü•à'; }
        else if (previousVoteCount < 50 && voteCount >=50) { awardAchieved = true; awardName = 'Gold Star'; awardEmoji = 'üåü'; }
        else if (previousVoteCount < 250 && voteCount >=250) { awardAchieved = true; awardName = 'Platinum Star'; awardEmoji = 'üèÜ'; }

        // display post-vote message
        displayPostVoteMessage(currentWord, voteType, themeUnlocked, awardAchieved);

        if (themeUnlocked || awardAchieved) {
          // show award message then continue
          showAwardMessageAndContinue(themeUnlocked ? `${currentTheme.charAt(0).toUpperCase()+currentTheme.slice(1)} Theme` : awardName, themeUnlocked ? 'üéÅ' : awardEmoji);
        } else {
          // normal flow -> transition to next
          setTimeout(() => {
            currentWordIndex = getWeightedRandomWordIndex(currentWordIndex);
            displayCurrentWord(allWords[currentWordIndex]);
            // fetch to refresh server state in background
            fetchWords(false);
          }, transitionDuration);
        }

      } catch (err) {
        console.error('Error submitting vote:', err);
        showMessage('Vote failed. Try again.', true);
        voteStreak = 0;
      } finally {
        // allow buttons to re-enable based on state (displayCurrentWord will set them)
        setTimeout(() => {
          if (!isCoolingDown && allWords[currentWordIndex]) displayCurrentWord(allWords[currentWordIndex]);
        }, 300);
      }
    }

    // post-vote message logic
    function displayPostVoteMessage(word, voteType, themeUnlocked, awardAchieved) {
      const messageDiv = postVoteMessage;
      if (themeUnlocked) { messageDiv.textContent = `üéâ New theme unlocked! Check the theme chooser.`; return; }
      if (awardAchieved) { messageDiv.textContent = `üåü New award unlocked! Check the badge area.`; return; }

      const isGoodOrBad = (voteType === 'good' || voteType === 'bad');
      if (isGoodOrBad) {
        const totalVotes = (word.goodVotes || 0) + (word.badVotes || 0);
        if (userSettings.showPercentages && totalVotes > 0) {
          const sameVotes = voteType === 'good' ? (word.goodVotes || 0) : (word.badVotes || 0);
          const pct = Math.round((sameVotes / totalVotes) * 100);
          const voteText = (voteType === 'good' ? 'Good' : 'Bad');
          messageDiv.textContent = `${voteText} vote registered! ${pct}% also voted '${voteText}' for this word. (${sameVotes}/${totalVotes})`;
          return;
        }
        if (userSettings.showTips) {
          voteCounterForTips++;
          localStorage.setItem('voteCounterForTips', voteCounterForTips);
          if (voteCounterForTips % TIP_COOLDOWN === 0) {
            const tip = TIPS[Math.floor(Math.random() * TIPS.length)];
            messageDiv.textContent = tip;
            return;
          }
        }
      }
      messageDiv.textContent = ' ';
    }

    function showAwardMessageAndContinue(awardName, emoji) {
      wordDisplay.textContent = `${emoji} ${awardName} Unlocked! ${emoji}`;
      wordDisplay.style.fontSize = '2.25rem';
      wordDisplay.style.color = '#10b981';
      wordDisplay.style.cursor = 'default';
      wordDisplay.className = 'text-4xl font-extrabold text-green-700 text-center min-h-[72px] animate-pulse';
      resetWordFrame();
      goodButton.disabled = badButton.disabled = notWordButton.disabled = true;
      setTimeout(() => {
        // continue
        currentWordIndex = getWeightedRandomWordIndex(currentWordIndex);
        displayCurrentWord(allWords[currentWordIndex]);
        fetchWords(false);
      }, 2500);
    }

    // ------ Submit custom word ------
    async function submitCustomWord() {
      const text = (newWordInput.value || '').trim();
      modalMessage.textContent = '';
      if (!text) { modalMessage.textContent = 'Word cannot be empty.'; return; }
      if (text.length > 45) { modalMessage.textContent = 'Word must be 45 characters or less.'; return; }
      if (text.includes(' ')) { modalMessage.textContent = 'Please enter a single word (no spaces).'; return; }

      submitWordButton.disabled = true;
      modalMessage.textContent = 'Submitting...';

      try {
        const resp = await fetch(API_BASE_URL, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ text })
        });
        const body = await (resp.headers.get('content-type') || '').includes('application/json') ? resp.json().catch(() => null) : null;
        if (resp.status === 201) {
          modalMessage.textContent = 'Success! Word added to the pool.';
          contributorCount++;
          localStorage.setItem('contributorCount', contributorCount);
          updateContributorBadge();
          setTimeout(() => { hideModal(); fetchWords(); }, 1000);
        } else {
          modalMessage.textContent = (body && body.message) ? body.message : `Failed to submit word (${resp.status})`;
        }
      } catch (err) {
        console.error('Error submitting custom word:', err);
        modalMessage.textContent = 'A network error occurred.';
      } finally {
        submitWordButton.disabled = false;
      }
    }
    function showModal() { submissionModal.classList.remove('hidden'); submissionModal.classList.add('flex'); newWordInput.value = ''; modalMessage.textContent=''; }
    function hideModal() { submissionModal.classList.remove('flex'); submissionModal.classList.add('hidden'); }

    // ------ Compare feature ------
    async function checkAndSubmitWord(text) {
      const t = (text || '').trim();
      if (!t) return { text: t.toUpperCase(), status: 'error', message: 'Empty' };
      const local = allWords.find(w => w.text.toUpperCase() === t.toUpperCase());
      if (local) return { text: t.toUpperCase(), status: 'exists', good: local.goodVotes||0, bad: local.badVotes||0 };
      try {
        const resp = await fetch(API_BASE_URL, { method: 'POST', headers: {'Content-Type':'application/json'}, body: JSON.stringify({ text: t }) });
        if (resp.status === 201) {
          contributorCount++; localStorage.setItem('contributorCount', contributorCount); updateContributorBadge();
          return { text: t.toUpperCase(), status: 'newlyAdded' };
        } else if (resp.status === 409) {
          return { text: t.toUpperCase(), status: 'exists' };
        } else {
          const body = await resp.json().catch(()=>null);
          return { text: t.toUpperCase(), status: 'error', message: (body && body.message) ? body.message : `Server ${resp.status}` };
        }
      } catch (err) {
        console.error('compare submit error', err);
        return { text: t.toUpperCase(), status: 'error', message: err.message || 'Network error' };
      }
    }

    async function runComparison() {
      const a = (wordOneInput.value || '').trim();
      const b = (wordTwoInput.value || '').trim();
      if (!a && !b) { compareResults.innerHTML = '<span class="text-red-500">Please enter at least one word to compare.</span>'; return; }
      runComparisonButton.disabled = true;
      compareResults.innerHTML = 'Analyzing words.';
      const results = [];
      if (a) results.push(await checkAndSubmitWord(a));
      if (b) {
        if (!a || a.toUpperCase() !== b.toUpperCase()) results.push(await checkAndSubmitWord(b));
        else if (a) results.push({ ...results[0], status: 'duplicate' });
      }
      let html = '';
      results.forEach((res, idx) => {
        const word = `<strong>${res.text}</strong>`;
        if (res.status === 'exists') {
          html += `<div class="${idx===0?'border-b pb-2 mb-2':''}"><p class="mb-2">Word ${idx+1} (${word}) exists in the database:</p><ul class="list-disc list-inside ml-4 mb-3 text-sm"><li>Good Votes: <span class="text-green-600 font-bold">${res.good}</span></li><li>Bad Votes: <span class="text-red-600 font-bold">${res.bad}</span></li><li>Score (Good - Bad): <span class="font-bold">${(res.good||0)-(res.bad||0)}</span></li></ul></div>`;
        } else if (res.status === 'newlyAdded') {
          html += `<p class="mb-3 text-purple-600 ${idx===0?'border-b pb-2':''}">Word ${idx+1} (${word}) was <strong>not found</strong> and has been <strong>added</strong> to the database! (0 Good, 0 Bad votes).</p>`;
        } else if (res.status === 'duplicate') {
          html += `<p class="mb-3 text-gray-500">Word 2 is a duplicate of Word 1 (${word}). Showing the same stats.</p>`;
        } else {
          html += `<p class="mb-3 text-red-500 ${idx===0?'border-b pb-2':''}">Word ${idx+1} (${word}) status could not be determined: ${res.message || 'Unknown'}</p>`;
        }
      });
      if (results.some(r => r.status === 'newlyAdded')) fetchWords(false);
      compareResults.innerHTML = html || '<span class="text-red-500">No valid words were entered.</span>';
      runComparisonButton.disabled = false;
    }

    // ------ Definition modal ------
    async function showDefinitionModal() {
      if (isCoolingDown || !allWords[currentWordIndex] || goodButton.disabled) return;
      const current = allWords[currentWordIndex];
      const wordText = (current.text || '').toLowerCase();
      definitionModalContainer.classList.remove('hidden'); definitionModalContainer.classList.add('flex');
      definitionWord.textContent = current.text.toUpperCase();
      definitionResults.innerHTML = '<p>Loading definition.</p>';
      try {
        const resp = await fetch(`https://api.dictionaryapi.dev/api/v2/entries/en/${encodeURIComponent(wordText)}`);
        if (!resp.ok) {
          if (resp.status === 404) { definitionResults.innerHTML = '<p class="text-red-500">Sorry, no definition was found for this word.</p>'; return; }
          throw new Error(`API error ${resp.status}`);
        }
        const data = await resp.json();
        definitionResults.innerHTML = formatDefinitionHtml(data);
      } catch (err) {
        console.error('Error fetching definition:', err);
        definitionResults.innerHTML = '<p class="text-red-500">An error occurred while fetching the definition.</p>';
      }
    }
    function hideDefinitionModal() { definitionModalContainer.classList.remove('flex'); definitionModalContainer.classList.add('hidden'); }
    function formatDefinitionHtml(data) {
      if (!data || !Array.isArray(data) || data.length === 0) return '<p class="text-red-500">Sorry, no definition was found.</p>';
      let html = '';
      const wordData = data[0];
      (wordData.meanings || []).forEach(meaning => {
        html += `<div class="mb-4"><h4 class="text-lg font-bold italic text-indigo-600">${meaning.partOfSpeech}</h4>`;
        html += '<ol class="list-decimal list-inside pl-4 mt-2 space-y-1">';
        (meaning.definitions || []).forEach(def => {
          html += `<li>${def.definition}</li>`;
          if (def.example) html += `<p class="text-sm text-gray-500 pl-4 italic">"${def.example}"</p>`;
        });
        html += '</ol></div>';
      });
      return html;
    }

    // ------ UI & Event wiring ------
    function loadSettingsToUI() {
      togglePercentages.checked = userSettings.showPercentages;
      toggleTips.checked = userSettings.showTips;
    }

    function updateSettingsFromUI() {
      userSettings.showPercentages = togglePercentages.checked;
      userSettings.showTips = toggleTips.checked;
      localStorage.setItem('userSettings', JSON.stringify(userSettings));
      postVoteMessage.textContent = 'Settings updated.';
      setTimeout(()=> postVoteMessage.textContent = ' ', 2000);
    }

    function showFullRankingsModal() {
      const { topGood, topBad } = getRankedWords(100);
      fullGoodRankingsDiv.innerHTML = topGood.map((r,i)=>`<div class="flex justify-between"><span>${i+1}. ${r.text}</span><span class="font-bold">${r.score} (${r.good}/${r.bad})</span></div>`).join('') || '<p>No data</p>';
      fullBadRankingsDiv.innerHTML = topBad.map((r,i)=>`<div class="flex justify-between"><span>${i+1}. ${r.text}</span><span class="font-bold">${-r.score} (${r.good}/${r.bad})</span></div>`).join('') || '<p>No data</p>';
      fullRankingsModalContainer.classList.remove('hidden'); fullRankingsModalContainer.classList.add('flex');
    }
    function hideFullRankingsModal() { fullRankingsModalContainer.classList.remove('flex'); fullRankingsModalContainer.classList.add('hidden'); }

    // clear local data
    function clearAllLocalData() {
      if (!confirm("Are you sure you want to clear ALL your local data (votes, awards, themes, streaks, settings)? This cannot be undone.")) return;
      localStorage.clear();
      alert("All local data has been cleared. The application will now reload.");
      window.location.reload();
    }

    // swipe handlers
    function handleTouchStart(evt) {
      if (isCoolingDown || goodButton.disabled) return;
      const t = evt.changedTouches[0]; startX = t.screenX; startY = t.screenY;
    }
    function handleTouchEnd(evt) {
      if (isCoolingDown || goodButton.disabled) return;
      const t = evt.changedTouches[0]; const endX = t.screenX, endY = t.screenY;
      const dx = endX - startX, dy = endY - startY;
      if (Math.abs(dx) > SWIPE_THRESHOLD && Math.abs(dx) > Math.abs(dy)) {
        if (dx > 0) submitVote('bad'); else submitVote('good');
      }
    }

    // central init
    function init() {
      // ensure userId
      if (!userId) { userId = crypto.randomUUID(); localStorage.setItem('userId', userId); }

      // apply version
      versionIndicator.textContent = `v${APP_VERSION} | Made by Gilxs in 12,025`;

      // restore counts
      voteCount = parseInt(localStorage.getItem('voteCount') || '0', 10);
      contributorCount = parseInt(localStorage.getItem('contributorCount') || '0', 10);
      updateAwardBadge(); updateContributorBadge();

      // event listeners
      goodButton.addEventListener('click', () => submitVote('good'));
      badButton.addEventListener('click', () => submitVote('bad'));
      notWordButton.addEventListener('click', () => submitVote('notWord'));
      customWordButton.addEventListener('click', showModal);
      cancelSubmitButton.addEventListener('click', hideModal);
      submitWordButton.addEventListener('click', submitCustomWord);

      gameCard.addEventListener('touchstart', handleTouchStart, {passive:true});
      gameCard.addEventListener('touchend', handleTouchEnd, {passive:true});

      showTop100Button.addEventListener('click', showFullRankingsModal);
      closeFullRankingsModal.addEventListener('click', hideFullRankingsModal);
      fullRankingsModalContainer.addEventListener('click', e => { if (e.target === fullRankingsModalContainer) hideFullRankingsModal(); });

      wordDisplay.addEventListener('click', showDefinitionModal);
      closeDefinitionModal.addEventListener('click', hideDefinitionModal);
      definitionModalContainer.addEventListener('click', e => { if (e.target === definitionModalContainer) hideDefinitionModal(); });

      compareWordsButton.addEventListener('click', () => { compareModalContainer.classList.remove('hidden'); compareModalContainer.classList.add('flex'); wordOneInput.value=''; wordTwoInput.value=''; compareResults.innerHTML='Type words above to compare them!'; });
      closeCompareModal.addEventListener('click', ()=>{ compareModalContainer.classList.remove('flex'); compareModalContainer.classList.add('hidden'); });
      compareModalContainer.addEventListener('click', e=> { if (e.target === compareModalContainer) { compareModalContainer.classList.remove('flex'); compareModalContainer.classList.add('hidden'); } });
      runComparisonButton.addEventListener('click', runComparison);

      showSettingsButton.addEventListener('click', ()=> { settingsModalContainer.classList.remove('hidden'); settingsModalContainer.classList.add('flex'); loadSettingsToUI(); });
      closeSettingsModal.addEventListener('click', ()=> { settingsModalContainer.classList.remove('flex'); settingsModalContainer.classList.add('hidden'); });
      settingsModalContainer.addEventListener('click', e => { if (e.target === settingsModalContainer) { settingsModalContainer.classList.remove('flex'); settingsModalContainer.classList.add('hidden'); } });
      togglePercentages.addEventListener('change', updateSettingsFromUI);
      toggleTips.addEventListener('change', updateSettingsFromUI);
      clearAllDataButton.addEventListener('click', clearAllLocalData);

      cakeBadge.addEventListener('click', () => findAndLoadSpecialWord(BOOSTED_WORD));
      llamaBadge.addEventListener('click', () => findAndLoadSpecialWord(LLAMA_WORD));
      themeChooser.addEventListener('change', (e) => applyTheme(e.target.value));

      // populate UI
      populateThemeChooser();
      applyTheme(currentTheme);
      updateSpecialBadges(null, true);
      loadSettingsToUI();

      // initial fetch
      fetchWords(true);

      // responsive resize
      window.addEventListener('resize', () => { if (allWords[currentWordIndex]) resizeWordToFit(); });
    }

    function findAndLoadSpecialWord(wordText) {
      const idx = allWords.findIndex(w => w.text.toUpperCase() === wordText.toUpperCase());
      if (idx !== -1) {
        currentWordIndex = idx;
        displayCurrentWord(allWords[currentWordIndex]);
        postVoteMessage.textContent = ' ';
      } else {
        showMessage(`The word '${wordText}' is not currently in the database. Please submit it via 'Submit Custom Word'.`, true);
      }
    }

    // expose a couple of debug hooks to console (like original)
    window.loadCakeWord = () => findAndLoadSpecialWord(BOOSTED_WORD);
    window.loadLlamaWord = () => findAndLoadSpecialWord(LLAMA_WORD);
    window.applyTheme = applyTheme;

    // run init
    window.addEventListener('load', init);
  })();
  </script>
</body>
</html>
