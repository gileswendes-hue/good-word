<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GOOD WORD / BAD WORD</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&display=swap" rel="stylesheet">
    <style>
        /* FIX: Prevents horizontal scrolling/stutter on mobile swipe/transition */
        html, body {
            overflow-x: hidden; 
        }

        body { 
            font-family: 'Inter', sans-serif; 
            overscroll-behavior-y: none; 
        }
        /* Base styling for all cards */
        .card { 
            backdrop-filter: blur(10px); 
            background-color: rgba(255, 255, 255, 0.95);
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.15);
            border: 1px solid rgba(0, 0, 0, 0.05);
            transition: transform 0.2s ease-out, box-shadow 0.2s ease-out;
            position: relative; 
            z-index: 10;
        }
        
        /* Base button styles */
        .good-button { background: linear-gradient(145deg, #10b981, #059669); }
        .bad-button { background: linear-gradient(145deg, #ef4444, #dc2626); }
        .not-word-button { background: linear-gradient(145deg, #64748b, #475569); }
        button { transition: transform 0.1s ease, box-shadow 0.1s ease; }
        button:active { transform: scale(0.98); box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2); }
        
        .version-indicator { 
            position: fixed; 
            bottom: 5px; 
            left: 50%; 
            transform: translateX(-50%); 
            font-size: 0.75rem; 
            color: #9ca3af; 
            z-index: 50; 
        }
        
        @media (max-width: 640px) {
            .rank-item { font-size: 0.8rem; }
            .vote-counts { font-size: 0.875rem; }
        }

        /* Animation Classes */
        .word-transition-good {
            animation: slide-out-left-good 0.7s ease-out forwards;
        }
        .word-transition-bad {
            animation: slide-out-right-bad 0.7s ease-out forwards;
        }
        
        /* LLAMA Slow Fade-Out */
        .word-fade-llama {
            transition: opacity 8s ease-out, transform 8s ease-out;
            opacity: 0 !important; 
            transform: scale(0.9) !important;
        }

        /* CAKE/POTATO/SQUIRREL Quick Fade-Out */
        .word-fade-quick {
            transition: opacity 0.3s ease-out, transform 0.3s ease-out;
            opacity: 0 !important; 
            transform: scale(0.95) !important;
        }

        /* OPTIMIZED ANIMATIONS: 
           Removed color transition to prevent mobile repaint stutter on heavy themes (Fire).
        */
        @keyframes slide-out-left-good {
            0% { transform: translateX(0); opacity: 1; }
            100% { transform: translateX(-150%); opacity: 0; }
        }
        
        @keyframes slide-out-right-bad {
            0% { transform: translateX(0); opacity: 1; }
            100% { transform: translateX(150%); opacity: 0; }
        }

        #wordDisplay {
            font-size: 6rem;
            white-space: nowrap; 
            overflow: hidden;
            max-width: 100%; 
            box-sizing: border-box;
            position: relative;
            z-index: 10;
            touch-action: none; 
            user-select: none;
            /* FIX: Force GPU promotion to prevent mobile stuttering on animations */
            will-change: transform, opacity; 
        }
        
        /* --- THEME STYLES --- */
        
        /* 0. DEFAULT THEME */
        body.theme-default { 
            background: linear-gradient(135deg, #fef2be 0%, #b5def0 100%) !important; 
        }
        .theme-default #gameCard {
            backdrop-filter: blur(10px); 
            background-color: rgba(255, 255, 255, 0.95);
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.15);
            border: 1px solid rgba(0, 0, 0, 0.05);
        }
        
        @keyframes rotate-border {
            0% { background-position: 0% 0%; }
            100% { background-position: 100% 100%; }
        }
        
        @keyframes rainbow-text {
            0% { -webkit-filter: hue-rotate(0deg); filter: hue-rotate(0deg); }
            100% { -webkit-filter: hue-rotate(360deg); filter: hue-rotate(360deg); }
        }

        /* 1. RAINBOW THEME */
        body.theme-rainbow { background: #f7f7f7 !important; }
        
        .theme-rainbow .thin-rainbow-frame {
            position: relative; 
            background-color: transparent; 
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
            border: none;
            z-index: 10;
        }
        .theme-rainbow .thin-rainbow-frame::before {
            content: ''; position: absolute; inset: -6px; border-radius: 1.25rem; 
            background: linear-gradient(45deg, #ff0000, #ff7f00, #ffff00, #00ff00, #00ffff, #0000ff, #9400d3, #ff0000);
            background-size: 400% 400%; animation: rotate-border 20s linear infinite; z-index: -3; 
        }
        .theme-rainbow .thin-rainbow-frame::after {
            content: ''; position: absolute; inset: -1px; border-radius: 1.1rem; background-color: #ffffff; z-index: -2; 
        }

        .theme-rainbow #gameCard, .theme-rainbow .ranking-card { 
            padding: 2.5rem !important; 
        }

        .theme-rainbow #wordFrame { padding: 0; background-color: transparent; margin-bottom: 1.5rem; }
        .theme-rainbow #wordDisplay {
            background: linear-gradient(45deg, #ff0000, #ff7f00, #ffff00, #00ff00, #00ffff, #0000ff, #9400d3);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent; color: transparent !important; 
            animation: rainbow-text 5s ease infinite; margin-bottom: 0 !important; padding: 0 0.5rem; line-height: 1; 
        }

        /* 2. DARK THEME */
        body.theme-dark { background: #121212 !important; }
        .theme-dark #gameCard {
            background-color: rgba(18, 18, 18, 0.95) !important; box-shadow: 0 15px 40px rgba(0, 0, 0, 0.5) !important; border: none !important; padding: 2rem !important; 
        }
        .theme-dark .card, .theme-dark .ranking-card {
            background-color: rgba(18, 18, 18, 0.95); box-shadow: 0 15px 40px rgba(0, 0, 0, 0.5); border: none; 
        }
        .theme-dark header .bg-white { background-color: #374151 !important; color: #d1d5db; }
        .theme-dark header .bg-gray-50 { background-color: #121212 !important; }
        .theme-dark #wordDisplay, .theme-dark .text-gray-900, .theme-dark .rank-item .text-gray-800 { color: #f3f4f6 !important; }
        .theme-dark .text-gray-500, .theme-dark .text-gray-600, .theme-dark .text-gray-800 { color: #9ca3af !important; }
        .theme-dark .border-b { border-color: #4b5563 !important; }

        /* 3. BANANA THEME */
        body.theme-banana { background: #f8f4b2 !important; }
        .theme-banana #wordDisplay { color: #ffd200; animation: bounce-word 0.5s ease-out infinite alternate; }
        @keyframes bounce-word { from { transform: translateY(0); } to { transform: translateY(-15px); } }
        .theme-banana #gameCard {
            background-color: rgba(255, 255, 255, 0.95) !important; border: 2px solid #f4ef81 !important;
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.15) !important; padding: 2rem !important; 
        }
        
        /* 4. WINTER THEME */
        body.theme-winter { background: linear-gradient(135deg, #e0f7fa 0%, #b3e5fc 100%) !important; }
        .theme-winter #wordDisplay { color: #01579b; text-shadow: 0 0 8px rgba(255, 255, 255, 0.8); }
        .theme-winter #gameCard {
            background-color: rgba(255, 255, 255, 0.9) !important; border: 2px solid #81d4fa !important; 
            box-shadow: 0 15px 40px rgba(179, 229, 252, 0.5) !important; padding: 2rem !important; 
        }

        .theme-winter #snow-effect {
            position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; overflow: hidden; z-index: 40; pointer-events: none;
        }

        .snow-particle {
            position: absolute; top: -20px; border-radius: 50%; background: white; pointer-events: none;
            animation: snow-fall linear infinite;
        }

        @keyframes snow-fall {
            0% { transform: translate(0, 0); opacity: 0; }
            10% { opacity: 1; }
            100% { transform: translate(var(--sway), 110vh); opacity: 0; }
        }

        /* 5. SUMMER THEME (REMASTERED) */
        body.theme-summer { 
            /* Blue Sky to Green Grass Gradient */
            background: linear-gradient(to bottom, #87CEEB 0%, #E0F7FA 50%, #4CAF50 50%, #2E7D32 100%) !important; 
            /* Radial gradient to simulate clouds overlay on the blue part */
            background-image: 
                radial-gradient(circle 60px at 10% 15%, rgba(255,255,255,0.8) 0%, rgba(255,255,255,0) 60%),
                radial-gradient(circle 50px at 15% 20%, rgba(255,255,255,0.8) 0%, rgba(255,255,255,0) 60%),
                radial-gradient(circle 80px at 85% 10%, rgba(255,255,255,0.8) 0%, rgba(255,255,255,0) 60%),
                radial-gradient(circle 60px at 90% 18%, rgba(255,255,255,0.8) 0%, rgba(255,255,255,0) 60%),
                linear-gradient(to bottom, #87CEEB 0%, #E0F7FA 50%, #4CAF50 50%, #2E7D32 100%) !important;
        }
        
        /* Sun Glow Animation for Summer Word */
        @keyframes sun-glow {
            0% { text-shadow: 0 0 20px #FFD700, 0 0 40px #FFA500; transform: scale(1); }
            50% { text-shadow: 0 0 40px #FFD700, 0 0 80px #FF4500; transform: scale(1.05); }
            100% { text-shadow: 0 0 20px #FFD700, 0 0 40px #FFA500; transform: scale(1); }
        }

        .theme-summer #wordDisplay { 
            color: #FFD700; /* Sun Gold */
            /* Animated sun glow */
            animation: sun-glow 3s ease-in-out infinite;
            text-shadow: 0 0 20px #FFD700, 0 0 40px #FF8C00; 
        }
        
        .theme-summer #gameCard {
            background-color: rgba(255, 255, 255, 0.85) !important; 
            border: 2px solid #FFEB3B !important;
            box-shadow: 0 15px 40px rgba(255, 193, 7, 0.4) !important; 
            padding: 2rem !important; 
        }

        /* 6. HALLOWEEN THEME */
        body.theme-halloween { background: linear-gradient(135deg, #000000 0%, #3a0000 100%) !important; }
        .theme-halloween #wordDisplay { color: #FF8C00; text-shadow: 0 0 20px rgba(255, 140, 0, 1), 0 0 5px rgba(255, 140, 0, 0.5); }
        .theme-halloween .card, .theme-halloween .ranking-card {
            background-color: rgba(10, 0, 0, 0.9) !important; border: 2px solid #FF8C00 !important;
            box-shadow: 0 0 30px rgba(255, 140, 0, 0.5), 0 15px 40px rgba(0, 0, 0, 0.7) !important; 
        }
        .theme-halloween #gameCard { padding: 2rem !important; }
        .theme-halloween .text-gray-900, .theme-halloween .rank-item .text-gray-800 { color: #F3F4F6 !important; }
        .theme-halloween .text-gray-500, .theme-halloween .text-gray-600 { color: #9CA3AF !important; }
        .theme-halloween header .bg-white { background-color: #3A015E !important; color: #d1d5db; }
        .theme-halloween header .bg-gray-50 { background-color: #1C1C1C !important; }
        .theme-halloween h2 { color: #FF8C00 !important; }
        .theme-halloween .border-b { border-color: #691C00 !important; }
        
        /* 7. SUBMARINE THEME */
        @keyframes bobbing-word {
            0% { transform: translateY(0px) rotate(-1deg); }
            50% { transform: translateY(-8px) rotate(1deg); }
            100% { transform: translateY(0px) rotate(-1deg); }
        }

        body.theme-submarine { background: linear-gradient(135deg, #020c1e 0%, #0a1931 50%, #183a5a 100%) !important; }
        .theme-submarine #wordDisplay {
            color: #b0e0e6; text-shadow: 0 0 10px rgba(176, 224, 230, 0.7), 0 0 5px rgba(255, 255, 255, 0.3);
            animation: bobbing-word 2.5s ease-in-out infinite;
        }
        .theme-submarine .card, .theme-submarine .ranking-card {
            background-color: rgba(10, 25, 49, 0.9) !important; border: 2px solid #1c4a7a !important;
            box-shadow: 0 0 20px rgba(28, 74, 122, 0.5), 0 15px 40px rgba(0, 0, 0, 0.7) !important; 
        }
        .theme-submarine #gameCard { padding: 2rem !important; }
        .theme-submarine .text-gray-900, .theme-submarine .rank-item .text-gray-800 { color: #F3F4F6 !important; }
        .theme-submarine .text-gray-500, .theme-submarine .text-gray-600 { color: #9CA3AF !important; }
        .theme-submarine header .bg-white { background-color: #0a1931 !important; color: #d1d5db; }
        .theme-submarine header .bg-gray-50 { background-color: #020c1e !important; }
        .theme-submarine h2 { color: #b0e0e6 !important; }
        .theme-submarine .border-b { border-color: #1c4a7a !important; }
        
        /* JS Controlled Bubble Particles */
        .theme-submarine #bubble-effect {
            position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; overflow: hidden; z-index: 40; pointer-events: none;
        }
        
        .bubble-particle {
            position: absolute;
            bottom: -50px;
            border-radius: 50%;
            background: radial-gradient(circle at 30% 30%, rgba(255, 255, 255, 0.15), rgba(255, 255, 255, 0.05) 60%, rgba(255, 255, 255, 0));
            box-shadow: inset 0 0 6px rgba(255, 255, 255, 0.3), 0 0 4px rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.15);
            opacity: 0;
            z-index: 0;
            animation: bubble-rise-float linear infinite;
        }
        
        @keyframes bubble-rise-float {
            0% { transform: translateY(0) translateX(0) scale(0.8); opacity: 0; }
            10% { opacity: 1; }
            50% { transform: translateY(-50vh) translateX(15px) scale(1); }
            100% { transform: translateY(-120vh) translateX(-15px) scale(1.1); opacity: 0; }
        }

        /* 8. FIRE THEME */
        body.theme-fire { background-color: rgb(48,8,8) !important; }
        
        .theme-fire #gameCard, .theme-fire .ranking-card {
             background-color: rgba(48, 8, 8, 0.95) !important; 
             border: 2px solid #ff5000 !important;
             box-shadow: 0 0 30px rgba(255, 80, 0, 0.3), 0 15px 40px rgba(0, 0, 0, 0.7) !important;
             padding: 2.5rem !important; 
        }
        
        .theme-fire #wordDisplay { 
            color: #ff5000; 
            text-shadow: 0 0 10px #ff5000, 0 0 20px #ff0000; 
        }
        .theme-fire .text-gray-900, .theme-fire .rank-item .text-gray-800 { color: #ffdcd0 !important; }
        .theme-fire .text-gray-500, .theme-fire .text-gray-600 { color: #a66 !important; }
        .theme-fire h2 { color: #ff5000 !important; }
        .theme-fire header .bg-white { background-color: #3d0a0a !important; color: #ffb3b3; }
        .theme-fire header .bg-gray-50 { background-color: #2b0505 !important; }
        .theme-fire .border-b { border-color: #801010 !important; }

        /* Fire Effect Container */
        .theme-fire #fire-effect {
            position: fixed; bottom: 0; left: 0; width: 100%; height: 100vh; 
            pointer-events: none; z-index: 5; overflow: hidden;
        }

        /* Particle Animation */
        .fire-particle {
            position: absolute; bottom: 0; border-radius: 50%; mix-blend-mode: screen;
            background-image: radial-gradient(rgb(255, 80, 0) 20%, rgba(255, 80, 0, 0) 70%);
            opacity: 0; width: 5em; height: 5em; animation: fire-rise 1s ease-in infinite;
        }

        @keyframes fire-rise {
            from { opacity: 0; transform: translateY(0) scale(1); }
            25% { opacity: 1; }
            to { opacity: 0; transform: translateY(-80vh) scale(0); }
        }
    </style>
</head>
<body class="flex flex-col items-center justify-center min-h-screen p-4 theme-default">

    <div id="snow-effect" class="fixed inset-0 pointer-events-none hidden"></div> 
    <div id="bubble-effect" class="hidden"></div> 
    <div id="fire-effect" class="hidden"></div>
    
<header class="text-center mb-8 w-full max-w-lg">
    <div id="logoArea" class="h-32 w-full flex items-center justify-center mb-4 relative">
        <div id="leftBadgeContainer" class="absolute left-0 top-1/2 transform -translate-y-1/2 grid grid-cols-2 gap-1 pl-4">
            <div id="cakeBadge" class="p-2 cursor-pointer text-3xl hidden transition duration-300 hover:scale-110" title="The cake is a lie! Click to go back to the word.">üéÇ</div>
            <div id="llamaBadge" class="p-2 cursor-pointer text-3xl hidden transition duration-300 hover:scale-110" title="The Llama has vanished! Click to go back to the word." >ü¶ô</div>
            <div id="potatoBadge" class="p-2 cursor-pointer text-3xl hidden transition duration-300 hover:scale-110" title="Potatoes gonna potate. Click to go back to the word.">ü•î</div>
            <div id="squirrelBadge" class="p-2 cursor-pointer text-3xl hidden transition duration-300 hover:scale-110" title="SQUIGGLE! Click to go back to the word.">üêøÔ∏è</div>
        </div>
        <img src="logo.png" alt="Good Word / Bad Word Logo" class="h-full w-auto max-w-full transform translate-x-4">
        <div id="rightBadgeContainer" class="absolute right-0 top-1/2 transform -translate-y-1/2 flex flex-col items-end space-y-1 pr-4">
            <div id="contributorBadge" class="p-2 cursor-pointer text-3xl hidden transition duration-300 hover:scale-110" title="Contributor Badge (0 Submissions)"></div>
            <div id="awardBadge" class="p-2 cursor-pointer text-3xl transition duration-300 hover:scale-110"></div>
        </div>
    </div>
    <div class="mt-4 flex justify-around p-3 rounded-t-xl bg-white shadow-md vote-counts">
        <div id="goodTotal" class="text-xl font-bold text-green-600">GOOD: 0</div>
        <div id="badTotal" class="text-xl font-bold text-red-600">BAD: 0</div>
    </div>
    <div class="flex justify-center p-2 rounded-b-xl bg-gray-50 shadow-md">
        <div id="wordCount" class="text-sm font-semibold text-gray-500">Words in Database: 0</div>
    </div>
</header>

    <main id="gameCard" class="card p-8 w-full max-w-sm flex flex-col items-center rounded-2xl">
        <div id="wordFrame" class="w-full text-center rounded-xl mb-8 relative">
            <div id="wordDisplay" class="font-extrabold text-gray-900 text-center min-h-[72px]">Loading...</div>
        </div>
        <div class="flex space-x-4 w-full mb-3">
            <button id="goodButton" class="good-button flex-1 py-4 text-white text-lg font-bold rounded-xl shadow-lg hover:shadow-xl focus:outline-none focus:ring-4 focus:ring-green-500/50" disabled>Good Word</button>
            <button id="badButton" class="bad-button flex-1 py-4 text-white text-lg font-bold rounded-xl shadow-lg hover:shadow-xl focus:outline-none focus:ring-4 focus:ring-red-500/50" disabled>Bad Word</button>
        </div>
        <button id="notWordButton" class="not-word-button w-full py-3 text-white text-lg font-bold rounded-xl shadow-lg hover:shadow-xl focus:outline-none focus:ring-4 focus:ring-slate-500/50" disabled>Not a word!</button>
        <button id="customWordButton" class="mt-4 text-sm text-gray-600 hover:text-gray-900 transition duration-150">Submit Custom Word</button>
    </main>

    <div id="postVoteMessage" class="mt-4 w-full max-w-sm text-center text-sm font-medium text-gray-600 min-h-[1.5rem] transition-opacity duration-500 opacity-0"></div>
    
    <section class="mt-8 w-full max-w-4xl grid grid-cols-1 md:grid-cols-2 gap-8">
        <div class="ranking-card card p-6 rounded-xl">
            <h2 class="text-xl font-bold text-green-700 mb-4 border-b pb-2">Top Good Words</h2>
            <div class="ranking-frame rounded-xl">
                <div id="goodRankings" class="space-y-2"><p class="text-gray-500">No data yet.</p></div>
            </div>
        </div>
        <div class="ranking-card card p-6 rounded-xl">
            <h2 class="text-xl font-bold text-red-700 mb-4 border-b pb-2">Top Bad Words</h2>
            <div class="ranking-frame rounded-xl">
                <div id="badRankings" class="space-y-2"><p class="text-gray-500">No data yet.</p></div>
            </div>
        </div>
    </section>
    
    <div class="mt-6 w-full max-w-4xl text-center">
        <button id="showTop100Button" class="px-6 py-2 bg-blue-600 text-white font-bold rounded-lg shadow-md hover:bg-blue-700 transition duration-150">Show Top 100 Rankings</button>
        <button id="compareWordsButton" class="mt-4 px-6 py-2 bg-purple-600 text-white font-bold rounded-lg shadow-md hover:bg-purple-700 transition duration-150">Compare Any Two Words</button>
    </div>

    <div class="mt-6 p-4 bg-white/70 rounded-xl w-full max-w-sm flex flex-col items-center shadow-lg border border-gray-100">
        <h3 class="text-lg font-bold text-gray-700 mb-2">Unlocked Themes üé®</h3>
        <select id="themeChooser" class="w-full p-2 border border-gray-300 rounded-lg focus:ring-indigo-500 focus:border-indigo-500 font-semibold">
            <option value="default">Default</option>
        </select>
        <p id="themeUnlockHint" class="text-xs text-gray-500 mt-2">Vote on special words to unlock new themes!</p>
        
        <div class="mt-4 flex space-x-2 w-full">
            <button id="showSettingsButton" class="flex-1 px-3 py-2 bg-slate-200 text-gray-700 font-bold rounded-lg shadow-md hover:bg-slate-300 transition duration-150 text-xs">‚öôÔ∏è Settings</button>
            <a href="mailto:gileswendes@gmail.com" class="flex-1 flex items-center justify-center px-3 py-2 bg-indigo-100 text-indigo-700 font-bold rounded-lg shadow-md hover:bg-indigo-200 transition duration-150 text-xs">‚úâÔ∏è Contact</a>
        </div>
    </div>
    
    <div id="submissionModal" class="fixed inset-0 bg-gray-900 bg-opacity-75 hidden items-center justify-center p-4 z-50">
        <div class="bg-white p-6 rounded-xl w-full max-w-md shadow-2xl">
            <h2 class="text-2xl font-bold mb-4">Submit a New Word</h2>
            <input type="text" id="newWordInput" placeholder="Enter your word here..." class="w-full p-3 border border-gray-300 rounded-lg mb-4 focus:ring-2 focus:ring-indigo-500">
            <div id="modalMessage" class="text-sm text-red-500 mb-4"></div>
            <div class="flex justify-end space-x-3">
                <button id="cancelSubmitButton" class="px-4 py-2 bg-gray-200 text-gray-700 font-medium rounded-lg hover:bg-gray-300 transition">Cancel</button>
                <button id="submitWordButton" class="px-4 py-2 bg-indigo-600 text-white font-medium rounded-lg hover:bg-indigo-700 transition">Submit Word</button>
            </div>
        </div>
    </div>
    
    <div id="fullRankingsModalContainer" class="fixed inset-0 bg-gray-900 bg-opacity-75 hidden items-center justify-center p-4 z-50">
        <div id="fullRankingsModal" class="bg-white p-6 rounded-xl w-full max-w-6xl max-h-[90vh] shadow-2xl flex flex-col">
            <div class="flex justify-between items-center mb-4 border-b pb-2">
                <h2 class="text-2xl font-bold">Top 100 Word Rankings</h2>
                <button id="closeFullRankingsModal" class="text-gray-500 hover:text-gray-800 text-2xl font-bold leading-none">&times;</button>
            </div>
            <div class="flex-grow overflow-y-auto">
                <div class="grid grid-cols-1 lg:grid-cols-2 gap-8">
                    <div class="bg-green-50/50 p-4 rounded-lg shadow-inner flex flex-col">
                        <h3 class="text-xl font-semibold mb-4 text-green-700">Top 100 Good Words</h3>
                        <div id="fullGoodRankings" class="space-y-1"></div>
                    </div>
                    <div class="bg-red-50/50 p-4 rounded-lg shadow-inner flex flex-col">
                        <h3 class="text-xl font-semibold mb-4 text-red-700">Top 100 Bad Words</h3>
                        <div id="fullBadRankings" class="space-y-1"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="definitionModalContainer" class="fixed inset-0 bg-gray-900 bg-opacity-75 hidden items-center justify-center p-4 z-50">
        <div id="definitionModal" class="bg-white p-6 rounded-xl w-full max-w-lg shadow-2xl flex flex-col max-h-[80vh]">
            <div class="flex justify-between items-center mb-4 border-b pb-2">
                <h2 id="definitionWord" class="text-2xl font-bold">DEFINITION</h2>
                <button id="closeDefinitionModal" class="text-gray-500 hover:text-gray-800 text-2xl font-bold leading-none">&times;</button>
            </div>
            <div id="definitionResults" class="space-y-4 overflow-y-auto"><p>Loading definition...</p></div>
        </div>
    </div>

    <div id="compareModalContainer" class="fixed inset-0 bg-gray-900 bg-opacity-75 hidden items-center justify-center p-4 z-50">
        <div id="compareModal" class="bg-white p-6 rounded-xl w-full max-w-lg shadow-2xl">
            <div class="flex justify-between items-center mb-4 border-b pb-2">
                <h2 class="text-2xl font-bold">Compare Any Two Words</h2>
                <button id="closeCompareModal" class="text-gray-500 hover:text-gray-800 text-2xl font-bold leading-none">&times;</button>
            </div>
            <div class="space-y-4">
                <input type="text" id="wordOneInput" placeholder="Enter first word..." class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-purple-500">
                <input type="text" id="wordTwoInput" placeholder="Enter second word..." class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-purple-500">
                <div id="compareResults" class="p-3 bg-gray-50 rounded-lg min-h-[50px]">Type words above to compare them!</div>
            </div>
            <div class="flex justify-end space-x-3 mt-4">
                <button id="runComparisonButton" class="px-4 py-2 bg-purple-600 text-white font-medium rounded-lg hover:bg-purple-700 transition">Compare</button>
            </div>
        </div>
    </div>
    
    <div id="settingsModalContainer" class="fixed inset-0 bg-gray-900 bg-opacity-75 hidden items-center justify-center p-4 z-50">
        <div id="settingsModal" class="bg-white p-6 rounded-xl w-full max-w-md shadow-2xl">
            <div class="flex justify-between items-center mb-4 border-b pb-2">
                <h2 class="text-2xl font-bold">User Settings</h2>
                <button id="closeSettingsModal" class="text-gray-500 hover:text-gray-800 text-2xl font-bold leading-none">&times;</button>
            </div>
            <div class="space-y-4">
                <div class="flex items-center justify-between">
                    <label for="togglePercentages" class="text-lg font-medium text-gray-700">Show Vote Percentages</label>
                    <input type="checkbox" id="togglePercentages" class="h-6 w-6 text-indigo-600 border-gray-300 rounded focus:ring-indigo-500">
                </div>
                <div class="flex items-center justify-between">
                    <label for="toggleTips" class="text-lg font-medium text-gray-700">Show Tips & Hints</label>
                    <input type="checkbox" id="toggleTips" class="h-6 w-6 text-indigo-600 border-gray-300 rounded focus:ring-indigo-500">
                </div>
            </div>
            <div class="mt-6 border-t pt-4">
                <p class="text-sm text-gray-500">You can clear all local data (votes, themes, etc.) below:</p>
                <button id="clearAllDataButton" class="mt-3 px-4 py-2 w-full bg-red-500 text-white font-medium rounded-lg shadow-md hover:bg-red-600 transition">Clear All Local Data</button>
            </div>
        </div>
    </div>
    
    <div class="version-indicator">v4.7.1 | Made by <a href="mailto:gileswendes@gmail.com">Gilxs</a> in 12,025</div>

    <script>
        const API_BASE_URL = '/api/words';
        const APP_VERSION = '4.7.1';

        // Special Words
        const BOOSTED_WORD = 'CAKE';
        const LLAMA_WORD = 'LLAMA';
        const POTATO_WORD = 'POTATO';
        const SQUIRREL_WORD = 'SQUIRREL';
        const BOOST_FACTOR = 2.0;

        // Probabilities
        const CAKE_PROBABILITY = 0.005;
        const LLAMA_PROBABILITY = 0.005;
        const POTATO_PROBABILITY = 0.005;
        const SQUIRREL_PROBABILITY = 0.005;

        const CONTRIBUTION_THRESHOLD = 5;
        const CAKE_WORD_FADE_DURATION = 300;
        const CAKE_MESSAGE_DURATION = 3000;
        
        const TIPS = [
            "Tip: You can now cast a vote by swiping on mobile devices! Drag the word left for good and right for bad.",
            "Tip: Have you tried comparing words? Use the 'Compare Any Two Words' button!",
            "Tip: Tap the word on the card to see its definition!",
            "Tip: Check out the theme chooser below to unlock new styles.",
            "Tip: You can turn off these messages in the Settings.",
            "Tip: Don't go mistaking your house burning down for the dawn.",
            "Tip: You could go outside for a stomp?",
            "Tip: Nobody else has a clue what's going on either.",
            "Tip: Ask them out for a coffee.",
            "Tip: Can you smell burning toast?",
            "Tip: Time is an illusion. Lunchtime doubly so.",
            "Tip: It is better to keep your mouth closed and let people think you are a fool than to open it and remove all doubt.",
            "Tip: It's the things that are given, not won, are the things that you earned",
            "Tip: You might roll your eyes at this, but I‚Äôm so glad that you exist.",
            "Tip: Play with friends! Not this, something classic like chess or Tetris."
        ];
        
        const TIP_COOLDOWN = 4;
        let voteCounterForTips = parseInt(localStorage.getItem('voteCounterForTips')) || 0;
        let messageTimeout = null;

        let allWords = [];
        let currentWordIndex = 0;
        let userId = localStorage.getItem('userId');
        let voteCount = parseInt(localStorage.getItem('voteCount')) || 0;
        let contributorCount = parseInt(localStorage.getItem('contributorCount')) || 0;
        let recentWordHistory = JSON.parse(localStorage.getItem('recentWordHistory')) || [];
        const HISTORY_SIZE = 10;
        let isSpecialMessage = false;

        // Badges
        let cakeBadgeUnlocked = localStorage.getItem('cakeBadgeUnlocked') === 'true';
        let llamaBadgeUnlocked = localStorage.getItem('llamaBadgeUnlocked') === 'true';
        let potatoBadgeUnlocked = localStorage.getItem('potatoBadgeUnlocked') === 'true';
        let squirrelBadgeUnlocked = localStorage.getItem('squirrelBadgeUnlocked') === 'true';

        // Elements
        const wordDisplay = document.getElementById('wordDisplay');
        const wordFrame = document.getElementById('wordFrame');
        const goodButton = document.getElementById('goodButton');
        const badButton = document.getElementById('badButton');
        const notWordButton = document.getElementById('notWordButton');
        const customWordButton = document.getElementById('customWordButton');
        const wordCount = document.getElementById('wordCount');
        const goodRankings = document.getElementById('goodRankings');
        const badRankings = document.getElementById('badRankings');
        const goodTotal = document.getElementById('goodTotal');
        const badTotal = document.getElementById('badTotal');
        const submissionModal = document.getElementById('submissionModal');
        const newWordInput = document.getElementById('newWordInput');
        const modalMessage = document.getElementById('modalMessage');
        const cancelSubmitButton = document.getElementById('cancelSubmitButton');
        const submitWordButton = document.getElementById('submitWordButton');
        const showTop100Button = document.getElementById('showTop100Button');
        const fullRankingsModalContainer = document.getElementById('fullRankingsModalContainer');
        const fullGoodRankings = document.getElementById('fullGoodRankings');
        const fullBadRankings = document.getElementById('fullBadRankings');
        const closeFullRankingsModal = document.getElementById('closeFullRankingsModal');
        const definitionModalContainer = document.getElementById('definitionModalContainer');
        const definitionModal = document.getElementById('definitionModal');
        const definitionWord = document.getElementById('definitionWord');
        const definitionResults = document.getElementById('definitionResults');
        const closeDefinitionModal = document.getElementById('closeDefinitionModal');
        const compareWordsButton = document.getElementById('compareWordsButton');
        const compareModalContainer = document.getElementById('compareModalContainer');
        const closeCompareModal = document.getElementById('closeCompareModal');
        const wordOneInput = document.getElementById('wordOneInput');
        const wordTwoInput = document.getElementById('wordTwoInput');
        const runComparisonButton = document.getElementById('runComparisonButton');
        const compareResults = document.getElementById('compareResults');
        const settingsModalContainer = document.getElementById('settingsModalContainer');
        const showSettingsButton = document.getElementById('showSettingsButton');
        const closeSettingsModal = document.getElementById('closeSettingsModal');
        const togglePercentages = document.getElementById('togglePercentages');
        const toggleTips = document.getElementById('toggleTips');
        const clearAllDataButton = document.getElementById('clearAllDataButton');
        const cakeBadge = document.getElementById('cakeBadge');
        const llamaBadge = document.getElementById('llamaBadge');
        const potatoBadge = document.getElementById('potatoBadge');
        const squirrelBadge = document.getElementById('squirrelBadge');
        const awardBadge = document.getElementById('awardBadge');
        const contributorBadge = document.getElementById('contributorBadge');
        const versionIndicator = document.querySelector('.version-indicator');
        const gameCard = document.getElementById('gameCard');
        const themeChooser = document.getElementById('themeChooser');
        const themeUnlockHint = document.getElementById('themeUnlockHint');
        
        // Theme Effects
        const snowEffect = document.getElementById('snow-effect');
        const bubbleEffect = document.getElementById('bubble-effect');
        const fireEffect = document.getElementById('fire-effect');


        // --- VOTE STREAK / COOLDOWN ---
        let cooldownEndTime = parseInt(localStorage.getItem('cooldownEndTime')) || 0;
        let mashCounter = 0;
        let voteStreak = 0;
        const MASH_LIMIT = 5;
        const COOLDOWN_SECONDS = 10;
        const STREAK_WINDOW_MS = 1500;
        let cooldownTimer = null;
        let isCoolingDown = false;
        let lastVoteTime = 0;

        // --- SWIPE TRACKING VARIABLES ---
        let isDragging = false;
        let startX = 0;
        let currentX = 0;
        let initialX = 0;
        let xOffset = 0;
        const SWIPE_THRESHOLD = 100;

        // --- THEME VARIABLES ---
        let currentTheme = localStorage.getItem('currentTheme') || 'default';
        let unlockedThemes = JSON.parse(localStorage.getItem('unlockedThemes')) || [];
        
        // Base64 Encoded Theme Triggers
        const ENCODED_THEMES = {
            'rainbow': 'UkFJTkJPV3xHQVl8U1BBUktMRXxDT0xPVVJ8UFJJREV8VU5JQ09STnxQUk9VRHxRVUVFUnxHTElUVEVSfExFU0JJQU58VElOU0VM',
            'dark': 'TUlETklHSFR8QkxBQ0t8U0hBREV8R09USHxTSEFET1d8TklOSkF8REFSS3xOSUdIVHxTVEVBTFRI',
            'banana': 'QkFOQU5BfEJBTkFOQVN8UExBTlRBSU58WUVMTE9XfFNQTElUfE1vbktFWXxIQU1NT0NL',
            'winter': 'U05PV01BTnxTTk9XfElDRXxXSU5URVJ8RlJPWkVOfENISUxMfENPTER8RkxBS0V8QkxJWlpBUkR8SUNJQ0xFfFNMRUlHSHxTTk9XQkFMTHxTQ0FSRnxKQUNLRVR8U0xFREdFfE5PVkVNQkVSfERFQ0VNQkVSfEpBTlVBUll8SklOR1NF',
            'summer': 'U1VNTUVSfEhPVHxCRUFDSHxIT0xJREFZfFNVTnxWQUNBVElPTnxTV0lNfFNBTkR8UE9PTHxKVUxZfEFVR1VTVHxKVU5F',
            'halloween': 'SEFMTE9XRUVOfEdIT1NUfFBVTVBLSU58U1BJREVSfFNXRUVUU3xDT1NUVU1FfFNQT09LWXxPQ1RPQkVSfFdJVENIfFZBTVBJUkV8Wk9NQklFfEJBVHxNT05TVEVS',
            'submarine': 'U1VCTUFSSU5FfFdBVEVSfFdBVkVTfFBMWU1PVVRIfEJSSVhIQU18UElSQVRFfFNFQXxBUVVBVElDfEFRVUF8REVFUHxPQ1RPUFVTfFJVTXxTSElQ',
            'fire': 'RklSRXxCVVJOfEhPVHxIRUxMfElORkVSTk98RkxBTUV8Q09BTFN8Q1JBQ0tMRXxUT0FTVHxIRUFU'
        };

        const THEME_WORDS = {};

        function decodeSecret(str) {
            try {
                return atob(str).split('|');
            } catch (e) {
                console.error("Error decoding secret:", e);
                return [];
            }
        }
        
        // Decode all theme words once on startup
        for (const [key, encoded] of Object.entries(ENCODED_THEMES)) {
            THEME_WORDS[key] = decodeSecret(encoded);
        }

        // --- UTILITY FUNCTIONS ---
        function checkStorage() {
            if (!userId) {
                userId = crypto.randomUUID();
                localStorage.setItem('userId', userId);
            }
            const storedVoteCount = localStorage.getItem('voteCount');
            if (storedVoteCount) {
                voteCount = parseInt(storedVoteCount, 10);
            }
            const storedContributorCount = localStorage.getItem('contributorCount');
            if (storedContributorCount) {
                contributorCount = parseInt(storedContributorCount, 10);
            }
        }

        function updateStatsAndRankings() {
            const rankedGood = getRankedWords('good', 10);
            const rankedBad = getRankedWords('bad', 10);
            
            goodRankings.innerHTML = rankedGood.map((w, i) => 
                `<div class="rank-item flex justify-between items-center border-b last:border-b-0 py-1 cursor-pointer hover:bg-green-50/50 rounded-sm px-1" data-word="${w.text}">
                    <span class="font-bold text-gray-800">${i + 1}. ${w.text.toUpperCase()}</span>
                    <span class="text-green-600 font-semibold">${w.goodVotes}</span>
                </div>`
            ).join('');
            
            badRankings.innerHTML = rankedBad.map((w, i) => 
                `<div class="rank-item flex justify-between items-center border-b last:border-b-0 py-1 cursor-pointer hover:bg-red-50/50 rounded-sm px-1" data-word="${w.text}">
                    <span class="font-bold text-gray-800">${i + 1}. ${w.text.toUpperCase()}</span>
                    <span class="text-red-600 font-semibold">${w.badVotes}</span>
                </div>`
            ).join('');
            
            // Add click listeners for definition modal
            document.querySelectorAll('.rank-item').forEach(item => {
                item.addEventListener('click', (e) => showDefinitionModal(e.currentTarget.dataset.word));
            });

            goodTotal.textContent = `GOOD: ${voteCount}`;
            badTotal.textContent = `BAD: ${voteCount}`; // Simple total vote count is displayed on both sides

            // Update badges
            updateBadge('cakeBadge', cakeBadgeUnlocked);
            updateBadge('llamaBadge', llamaBadgeUnlocked);
            updateBadge('potatoBadge', potatoBadgeUnlocked);
            updateBadge('squirrelBadge', squirrelBadgeUnlocked);
            updateContributorBadge();
            updateAwardBadge();
        }

        function updateBadge(badgeId, isUnlocked, init = true) {
            const badge = document.getElementById(badgeId);
            if (isUnlocked) {
                badge.classList.remove('hidden');
                if (!init) { // Add temporary animation on unlock
                    badge.classList.add('animate-ping', 'bg-yellow-300', 'rounded-full');
                    setTimeout(() => {
                        badge.classList.remove('animate-ping', 'bg-yellow-300', 'rounded-full');
                    }, 1000);
                }
            } else {
                if (init) {
                    badge.classList.add('hidden', 'cursor-pointer');
                }
            }
        }

        function updateContributorBadge() {
            if (contributorCount >= CONTRIBUTION_THRESHOLD) {
                contributorBadge.textContent = '‚úçÔ∏è';
                contributorBadge.title = `Contributor Badge (${contributorCount} Submissions)`;
                contributorBadge.classList.remove('hidden');
            } else {
                contributorBadge.classList.add('hidden');
            }
        }

        function updateAwardBadge() {
            let emoji = '‚≠êÔ∏è';
            let title = 'Rookie Voter (0 Votes)';
            if (voteCount >= 250) {
                emoji = 'üèÜ';
                title = 'Platinum Star Award (250+ Votes)';
            } else if (voteCount >= 100) {
                emoji = 'üåü';
                title = 'Gold Star Award (100+ Votes)';
            } else if (voteCount >= 50) {
                emoji = '‚ú®';
                title = 'Silver Star Award (50+ Votes)';
            } else if (voteCount >= 10) {
                emoji = '‚≠ê';
                title = 'Bronze Star Award (10+ Votes)';
            }
            awardBadge.textContent = emoji;
            awardBadge.title = title;
        }

        function updateSettings() {
            localStorage.setItem('showPercentages', togglePercentages.checked);
            localStorage.setItem('showTips', toggleTips.checked);
        }

        function loadSettings() {
            const showPercentages = localStorage.getItem('showPercentages') === 'true';
            const showTips = localStorage.getItem('showTips') !== 'false'; // Default to true if not set
            togglePercentages.checked = showPercentages;
            toggleTips.checked = showTips;
        }

        function clearAllLocalData() {
            if (confirm("Are you sure you want to clear ALL local data? This includes your user ID, vote count, themes, and history.")) {
                localStorage.clear();
                window.location.reload();
            }
        }
        
        function loadCakeWord() {
            showSpecialWord('cake');
        }

        function loadLlamaWord() {
            showSpecialWord('llama');
        }

        function loadPotatoWord() {
            showSpecialWord('potato');
        }

        function loadSquirrelWord() {
            showSpecialWord('squirrel');
        }

        function showSpecialWord(type) {
            isSpecialMessage = true;
            let word;
            if (type === 'cake') {
                word = { text: BOOSTED_WORD, isSpecialMessage: true };
            } else if (type === 'llama') {
                word = { text: LLAMA_WORD, isSpecialMessage: true };
            } else if (type === 'potato') {
                word = { text: POTATO_WORD, isSpecialMessage: true };
            } else if (type === 'squirrel') {
                word = { text: SQUIRREL_WORD, isSpecialMessage: true };
            }
            displayCurrentWord(word);
            // Hide the badge after displaying the word
            document.getElementById(`${type}Badge`).classList.add('hidden', 'cursor-pointer');
            // Remove the corresponding flag from localStorage to hide the badge persistence
            localStorage.removeItem(`${type}BadgeUnlocked`);

            // Find the special word in allWords and update its index
            const specialIndex = allWords.findIndex(w => w.text.toUpperCase() === word.text);
            if (specialIndex !== -1) {
                currentWordIndex = specialIndex;
            } else {
                 // In case the word isn't in the fetched list (shouldn't happen)
                 currentWordIndex = -1;
            }
        }

        function updateSpecialBadges(wordText) {
            if (wordText.toUpperCase() === BOOSTED_WORD) {
                cakeBadgeUnlocked = true;
                localStorage.setItem('cakeBadgeUnlocked', 'true');
            } else if (wordText.toUpperCase() === LLAMA_WORD) {
                llamaBadgeUnlocked = true;
                localStorage.setItem('llamaBadgeUnlocked', 'true');
            } else if (wordText.toUpperCase() === POTATO_WORD) {
                potatoBadgeUnlocked = true;
                localStorage.setItem('potatoBadgeUnlocked', 'true');
            } else if (wordText.toUpperCase() === SQUIRREL_WORD) {
                squirrelBadgeUnlocked = true;
                localStorage.setItem('squirrelBadgeUnlocked', 'true');
            }
        }

        function populateThemeChooser() {
            themeChooser.innerHTML = '<option value="default">Default</option>';
            
            const availableThemes = [...new Set(unlockedThemes)].sort();
            const allThemeKeys = Object.keys(THEME_WORDS);

            for (const key of allThemeKeys) {
                if (unlockedThemes.includes(key) && !availableThemes.includes(key)) {
                    availableThemes.push(key);
                }
            }

            availableThemes.sort().forEach(themeKey => {
                const themeName = themeKey.charAt(0).toUpperCase() + themeKey.slice(1);
                const option = document.createElement('option');
                option.value = themeKey;
                option.textContent = themeName;
                themeChooser.appendChild(option);
            });
            
            themeChooser.value = currentTheme;

            if (availableThemes.length > 0) {
                themeUnlockHint.textContent = `You have ${availableThemes.length} themes unlocked!`;
            } else {
                themeUnlockHint.textContent = `Vote on special words to unlock new themes!`;
            }
        }

        // Generate random fire particles
        function generateFireParticles() {
            if (!fireEffect) return;
            fireEffect.innerHTML = '';
            const parts = 50;
            for (let i = 0; i < parts; i++) {
                const particle = document.createElement('div');
                particle.className = 'fire-particle';
                const delay = Math.random();
                const left = (i / parts) * 100;
                particle.style.animationDelay = `${delay}s`;
                particle.style.left = `calc((100% - 5em) * ${left/100})`;
                fireEffect.appendChild(particle);
            }
        }

        // Generate random bubble particles with clustering
        function generateBubbleParticles() {
            if (!bubbleEffect) return;
            bubbleEffect.innerHTML = '';
            const parts = 40;
            const clusters = [10, 30, 70, 90]; // X percentages for clustering
            
            for (let i = 0; i < parts; i++) {
                const particle = document.createElement('div');
                particle.className = 'bubble-particle';
                const size = Math.random() * 30 + 10;
                particle.style.width = `${size}px`;
                particle.style.height = `${size}px`;

                // Calculate horizontal position with clustering bias
                let clusterCenter = clusters[Math.floor(Math.random() * clusters.length)];
                let left = clusterCenter + (Math.random() * 20 - 10); // +/- 10% around cluster center
                left = Math.max(0, Math.min(100, left)); // Clamp between 0 and 100

                // Random animation properties
                const delay = Math.random() * 10;
                const duration = Math.random() * 10 + 5; // 5s to 15s

                particle.style.left = `${left}%`;
                particle.style.animationDelay = `-${delay}s`;
                particle.style.animationDuration = `${duration}s`;
                bubbleEffect.appendChild(particle);
            }
        }

        // Generate random snow particles
        function generateSnowParticles() {
            if (!snowEffect) return;
            snowEffect.innerHTML = '';
            const flakes = 30; // Fewer flakes for better performance

            for (let i = 0; i < flakes; i++) {
                const flake = document.createElement('div');
                flake.className = 'snow-particle';
                
                // Random size
                const size = Math.random() * 5 + 3; // 3px to 8px
                flake.style.width = `${size}px`;
                flake.style.height = `${size}px`;

                // Random horizontal position (off-screen start at top)
                const startLeft = Math.random() * 100;
                flake.style.left = `${startLeft}vw`;

                // Random horizontal sway via CSS Variable
                // Random number between -50px and 50px
                const sway = (Math.random() - 0.5) * 100;
                flake.style.setProperty('--sway', `${sway}px`);

                // Animation duration (fall speed)
                const duration = Math.random() * 10 + 5; // 5s to 15s
                flake.style.animationDuration = `${duration}s`;

                // Delay so they don't all start at once
                flake.style.animationDelay = `-${Math.random() * 15}s`;

                snowEffect.appendChild(flake);
            }
        }

        function applyTheme(theme) {
            document.body.className = document.body.className.split(' ').filter(c => !c.startsWith('theme-')).join(' ');
            const themeToApply = theme === 'default' ? 'default' : theme;
            document.body.classList.add(`theme-${themeToApply}`);
            currentTheme = theme;
            localStorage.setItem('currentTheme', currentTheme);

            // Handle Winter/Snow Theme
            if (snowEffect) {
                if (theme === 'winter') {
                    snowEffect.classList.remove('hidden');
                    generateSnowParticles();
                } else {
                    snowEffect.classList.add('hidden');
                    snowEffect.innerHTML = '';
                }
            }

            // Handle Submarine/Bubble Theme
            if (bubbleEffect) {
                if (theme === 'submarine') {
                    bubbleEffect.classList.remove('hidden');
                    generateBubbleParticles();
                } else {
                    bubbleEffect.classList.add('hidden');
                    bubbleEffect.innerHTML = '';
                }
            }
            
            // Handle Fire Theme
            if (fireEffect) {
                if (theme === 'fire') {
                    fireEffect.classList.remove('hidden');
                    generateFireParticles();
                } else {
                    fireEffect.classList.add('hidden');
                    fireEffect.innerHTML = '';
                }
            }

            // Handle Rainbow card styling
            const rankingCards = document.querySelectorAll('.ranking-card');
            if (theme === 'rainbow') {
                gameCard.classList.add('thin-rainbow-frame');
                gameCard.classList.remove('card');
                rankingCards.forEach(card => {
                    card.classList.add('thin-rainbow-frame');
                    card.classList.remove('card');
                });
            } else {
                gameCard.classList.remove('thin-rainbow-frame');
                gameCard.classList.add('card');
                rankingCards.forEach(card => {
                    card.classList.remove('thin-rainbow-frame');
                    card.classList.add('card');
                });
            }
        }

        function checkAndApplyTheme(wordText) {
            const upperWord = wordText.toUpperCase();
            let newlyUnlocked = false;

            for (const [theme, words] of Object.entries(THEME_WORDS)) {
                if (words.includes(upperWord)) {
                    if (!unlockedThemes.includes(theme)) {
                        unlockedThemes.push(theme);
                        localStorage.setItem('unlockedThemes', JSON.stringify(unlockedThemes));
                        newlyUnlocked = true;
                        populateThemeChooser();
                    }
                }
            }
            return newlyUnlocked;
        }

        function showAwardMessageAndContinue(awardName, emoji) {
            wordDisplay.textContent = `${emoji} ${awardName} Unlocked! ${emoji}`;
            wordDisplay.style.fontSize = '2.25rem';
            wordDisplay.style.color = '#10b981';
            wordDisplay.style.cursor = 'default';
            wordDisplay.className = 'text-4xl font-extrabold text-green-700 text-center min-h-[72px] animate-pulse';
            wordFrame.style.padding = '0';
            wordFrame.style.backgroundColor = 'transparent';
            
            goodButton.disabled = true;
            badButton.disabled = true;
            notWordButton.disabled = true;

            document.getElementById('postVoteMessage').classList.add('opacity-0');

            setTimeout(() => {
                wordDisplay.classList.remove('animate-pulse');
                nextWord();
                fetchWords(false);
            }, 2500);
        }

        function showMessage(text, isError = false) {
            isSpecialMessage = true;
            wordDisplay.textContent = text;
            wordDisplay.className = `text-4xl font-bold text-center min-h-[72px] ${isError ? 'text-red-500' : 'text-gray-500'}`;
            wordDisplay.style.fontSize = '1.0rem';
            wordDisplay.style.cursor = 'default';
            wordFrame.style.padding = '0';
            wordFrame.style.backgroundColor = 'transparent';
            goodButton.disabled = true;
            badButton.disabled = true;
            notWordButton.disabled = true;
        }

        function showCooldownMessage(remainingSeconds) {
            wordDisplay.textContent = `Button mashing will not be tolerated. Wait ${remainingSeconds}s...`;
            wordDisplay.className = 'text-4xl font-bold text-red-600 text-center min-h-[72px]';
            wordDisplay.style.fontSize = '1.5rem';
            wordDisplay.style.cursor = 'default';
            wordFrame.style.padding = '0';
            wordFrame.style.backgroundColor = 'transparent';
            goodButton.disabled = true;
            badButton.disabled = true;
            notWordButton.disabled = true;
        }

        function showStatsMessage(type) {
            const messageDiv = document.getElementById('postVoteMessage');
            if (messageTimeout) clearTimeout(messageTimeout);
            
            let msg = '';
            if (type === 'award') {
                let title = 'No Award Yet';
                if (voteCount >= 250) title = 'Platinum Star Award (250+ Votes)';
                else if (voteCount >= 100) title = 'Gold Star Award (100+ Votes)';
                else if (voteCount >= 50) title = 'Silver Star Award (50+ Votes)';
                else if (voteCount >= 10) title = 'Bronze Star Award (10+ Votes)';
                else title = `Rookie Voter (${voteCount}/10 Votes)`;
                msg = `Current Award: ${title}`;
            } else if (type === 'contributor') {
                const needed = CONTRIBUTION_THRESHOLD - contributorCount;
                if (contributorCount >= CONTRIBUTION_THRESHOLD) {
                    msg = `Contributor Badge Unlocked! (${contributorCount} accepted submissions)`;
                } else {
                    msg = `Submit ${needed} more words to unlock the Contributor Badge!`;
                }
            }

            if (!msg) return;

            messageDiv.classList.remove('opacity-100');
            messageDiv.classList.add('opacity-0');
            setTimeout(() => {
                messageDiv.innerHTML = msg;
                messageDiv.classList.remove('opacity-0');
                messageDiv.classList.add('opacity-100');
                messageTimeout = setTimeout(() => {
                    messageDiv.classList.remove('opacity-100');
                    messageDiv.classList.add('opacity-0');
                }, 5000);
            }, 150);
        }

        function displayTip() {
            if (localStorage.getItem('showTips') === 'false') return;

            const messageDiv = document.getElementById('postVoteMessage');
            if (messageTimeout) clearTimeout(messageTimeout);

            const tipIndex = voteCounterForTips % TIPS.length;
            const tipText = TIPS[tipIndex];

            messageDiv.classList.remove('opacity-100');
            messageDiv.classList.add('opacity-0');
            setTimeout(() => {
                messageDiv.innerHTML = tipText;
                messageDiv.classList.remove('opacity-0');
                messageDiv.classList.add('opacity-100');
                messageTimeout = setTimeout(() => {
                    messageDiv.classList.remove('opacity-100');
                    messageDiv.classList.add('opacity-0');
                }, 8000); // Longer duration for tips
            }, 150);
        }

        function displayPostVoteMessage(updatedWordData, voteType, themeWasNewlyUnlocked, awardAchieved) {
            const messageDiv = document.getElementById('postVoteMessage');
            if (messageTimeout) clearTimeout(messageTimeout);
            
            let messageContent = '';
            
            if (themeWasNewlyUnlocked || awardAchieved) {
                // If a theme or award was unlocked, the post-vote message is skipped in favor of the showAwardMessageAndContinue
                return;
            }

            const showPercentages = localStorage.getItem('showPercentages') === 'true';

            if (updatedWordData) {
                const totalVotes = (updatedWordData.goodVotes || 0) + (updatedWordData.badVotes || 0);
                if (totalVotes === 0) {
                    messageContent = "Your vote is the first! Let's see what others think.";
                } else {
                    if (!showPercentages) {
                        messageContent = `${voteType === 'good' ? 'Good' : 'Bad'} vote registered!`;
                    } else {
                        const sameVotes = voteType === 'good' ? (updatedWordData.goodVotes || 0) : (updatedWordData.badVotes || 0);
                        const percentage = Math.round((sameVotes / totalVotes) * 100);
                        const voteText = voteType === 'good' ? 'Good' : 'Bad';
                        messageContent = `${voteText} vote registered! ${percentage}% of people also voted '${voteText}'. (${sameVotes}/${totalVotes})`;
                    }
                }
            }

            if (!messageContent) return;

            messageDiv.classList.remove('opacity-100');
            messageDiv.classList.add('opacity-0');
            setTimeout(() => {
                messageDiv.innerHTML = messageContent;
                messageDiv.classList.remove('opacity-0');
                messageDiv.classList.add('opacity-100');
                messageTimeout = setTimeout(() => {
                    messageDiv.classList.remove('opacity-100');
                    messageDiv.classList.add('opacity-0');
                }, 5000);
            }, 150);
        }

        function displayCurrentWord(currentWord) {
            isSpecialMessage = currentWord.isSpecialMessage || false;
            
            if (!currentWord) {
                showMessage("No words available! Try submitting one.", false);
                return;
            }

            const wordText = currentWord.text.toUpperCase();
            
            wordDisplay.classList.remove('word-transition-good', 'word-transition-bad', 'word-fade-llama', 'word-fade-cake', 'word-fade-quick');
            wordDisplay.textContent = wordText;
            wordDisplay.className = 'font-extrabold text-gray-900 text-center min-h-[72px]';
            
            // Clear all inline styles that might interfere with themes/animation
            wordDisplay.style.background = '';
            wordDisplay.style.webkitBackgroundClip = '';
            wordDisplay.style.webkitTextFillColor = '';
            wordDisplay.style.color = '#111827';
            wordDisplay.style.animation = '';
            wordDisplay.style.transform = '';
            wordDisplay.style.textShadow = '';
            wordDisplay.style.opacity = '1';
            wordDisplay.style.cursor = 'default';
            wordDisplay.style.removeProperty('animation');

            wordFrame.style.padding = '0';
            wordFrame.style.backgroundColor = 'transparent';
            
            // Re-apply theme-specific styles
            if (currentTheme === 'dark' || currentTheme === 'halloween' || currentTheme === 'submarine' || currentTheme === 'fire') {
                wordDisplay.style.color = '#f3f4f6';
                if (currentTheme === 'halloween') {
                    wordDisplay.style.color = '#FF8C00'; 
                    wordDisplay.style.textShadow = '0 0 20px rgba(255, 140, 0, 1), 0 0 5px rgba(255, 140, 0, 0.5)';
                } else if (currentTheme === 'submarine') {
                    wordDisplay.style.color = '#b0e0e6';
                    wordDisplay.style.textShadow = '0 0 10px rgba(176, 224, 230, 0.7), 0 0 5px rgba(255, 255, 255, 0.3)';
                    wordDisplay.style.animation = 'bobbing-word 2.5s ease-in-out infinite';
                } else if (currentTheme === 'fire') {
                    wordDisplay.style.color = '#ff5000'; 
                    wordDisplay.style.textShadow = '0 0 10px #ff5000, 0 0 20px #ff0000'; 
                }
            } else if (currentTheme === 'rainbow') {
                wordDisplay.style.background = 'linear-gradient(45deg, #ff0000, #ff7f00, #ffff00, #00ff00, #00ffff, #0000ff, #9400d3)';
                wordDisplay.style.webkitBackgroundClip = 'text';
                wordDisplay.style.webkitTextFillColor = 'transparent';
                wordDisplay.style.color = 'transparent';
                wordDisplay.style.animation = 'rainbow-text 5s ease infinite';
            } else if (currentTheme === 'banana') {
                wordDisplay.style.color = '#ffd200';
                wordDisplay.style.animation = 'bounce-word 0.5s ease-out infinite alternate';
            } else if (currentTheme === 'winter') {
                wordDisplay.style.color = '#01579b'; 
                wordDisplay.style.textShadow = '0 0 8px rgba(255, 255, 255, 0.8)';
            } else if (currentTheme === 'summer') {
                wordDisplay.style.color = '#FFD700';
                wordDisplay.style.textShadow = '0 0 20px #FFD700, 0 0 40px #FF8C00'; 
                wordDisplay.style.animation = 'sun-glow 3s ease-in-out infinite';
            }

            // Text fitting logic
            const maxFontSize = 96; // 6rem in tailwind
            const cardContentWidth = gameCard.clientWidth - (parseFloat(window.getComputedStyle(gameCard).paddingLeft) * 2);
            let wordDisplayPaddingHorizontal = 0;
            let maxAvailableWidthForTextContent = cardContentWidth;
            
            if (currentTheme === 'rainbow') {
                wordDisplay.style.padding = '0 0.5rem';
                wordDisplayPaddingHorizontal = parseFloat(window.getComputedStyle(wordDisplay).paddingLeft) * 2;
                maxAvailableWidthForTextContent = cardContentWidth - wordDisplayPaddingHorizontal;
            } else {
                wordDisplay.style.padding = '0 1rem';
                wordDisplayPaddingHorizontal = parseFloat(window.getComputedStyle(wordDisplay).paddingLeft) * 2;
                maxAvailableWidthForTextContent = cardContentWidth - wordDisplayPaddingHorizontal;
            }

            wordDisplay.style.fontSize = `${maxFontSize}px`;
            wordDisplay.style.whiteSpace = 'nowrap';
            
            let currentTextWidth = wordDisplay.scrollWidth;
            let finalFontSize = maxFontSize;

            if (currentTextWidth > maxAvailableWidthForTextContent) {
                const scaleFactor = maxAvailableWidthForTextContent / currentTextWidth;
                finalFontSize = Math.floor(maxFontSize * scaleFactor);
                if (finalFontSize < 24) finalFontSize = 24;
            }
            
            wordDisplay.style.fontSize = `${finalFontSize}px`;
            wordDisplay.style.whiteSpace = 'normal';

            if (!isCoolingDown && !currentWord.isSpecialMessage) {
                wordDisplay.style.cursor = 'grab';
                goodButton.disabled = false;
                badButton.disabled = false;
                notWordButton.disabled = false;
            }
        }

        // UPDATED: Random selection with history buffer
        function getWeightedRandomWordIndex() {
            if (allWords.length === 0) return -1;
            
            const random = Math.random();
            let specialWordText = null, specialWordIndex = -1;

            if (!cakeBadgeUnlocked && random < CAKE_PROBABILITY) {
                specialWordText = BOOSTED_WORD;
            } else if (!llamaBadgeUnlocked && random >= CAKE_PROBABILITY && random < (CAKE_PROBABILITY + LLAMA_PROBABILITY)) {
                specialWordText = LLAMA_WORD;
            } else if (!potatoBadgeUnlocked && random >= (CAKE_PROBABILITY + LLAMA_PROBABILITY) && random < (CAKE_PROBABILITY + LLAMA_PROBABILITY + POTATO_PROBABILITY)) {
                specialWordText = POTATO_WORD;
            } else if (!squirrelBadgeUnlocked && random >= (CAKE_PROBABILITY + LLAMA_PROBABILITY + POTATO_PROBABILITY) && random < (CAKE_PROBABILITY + LLAMA_PROBABILITY + POTATO_PROBABILITY + SQUIRREL_PROBABILITY)) {
                specialWordText = SQUIRREL_WORD;
            }

            if (specialWordText) {
                specialWordIndex = allWords.findIndex(w => w.text.toUpperCase() === specialWordText);
                if (specialWordIndex !== -1) return specialWordIndex;
            }

            const totalVotes = allWords.reduce((sum, w) => sum + (w.goodVotes || 0) + (w.badVotes || 0) + 1, 0);

            const weightedWords = allWords.map((word, index) => {
                const isRecent = recentWordHistory.includes(index);
                const votes = (word.goodVotes || 0) + (word.badVotes || 0);
                const baseWeight = 1;
                
                // Weight inversely proportional to total votes, boosted for unvoted words
                let weight = baseWeight + (totalVotes === 0 ? 0 : (totalVotes - votes) / totalVotes);
                
                // Additional boost for unvoted words
                if (votes === 0) weight *= BOOST_FACTOR; 
                
                // Penalty for recent words
                if (isRecent) weight *= 0.1;
                
                return { index, weight };
            });

            let totalWeight = weightedWords.reduce((sum, w) => sum + w.weight, 0);
            let randomNum = Math.random() * totalWeight;

            for (const word of weightedWords) {
                randomNum -= word.weight;
                if (randomNum <= 0) return word.index;
            }

            return weightedWords[weightedWords.length - 1].index;
        }

        function nextWord() {
            if (allWords.length === 0) return;

            // Get new index
            const newIndex = getWeightedRandomWordIndex();

            // Update History Buffer
            if (newIndex !== -1) {
                recentWordHistory.push(newIndex);
                if (recentWordHistory.length > HISTORY_SIZE) {
                    recentWordHistory.shift(); // Remove oldest
                }
                localStorage.setItem('recentWordHistory', JSON.stringify(recentWordHistory));
            }

            currentWordIndex = newIndex;
            displayCurrentWord(allWords[currentWordIndex]);
            isSpecialMessage = false;

            // Show tip every TIP_COOLDOWN votes
            if (voteCounterForTips % TIP_COOLDOWN === 0 && voteCounterForTips > 0) {
                displayTip();
            }
        }

        async function fetchWords(updateDisplay = true) {
            try {
                if(updateDisplay) showMessage("Loading words...", false);
                const response = await fetch(API_BASE_URL);
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                
                let fetchedWords = await response.json();
                const availableWords = fetchedWords.filter(w => (w.notWordVotes || 0) < 3);
                allWords = availableWords;

                wordCount.textContent = `Words in Database: ${fetchedWords.length}`;

                if (allWords.length > 0) {
                    updateStatsAndRankings();
                    if (updateDisplay) {
                        // Initial Load: Seed history so first word isn't repeated immediately
                        currentWordIndex = getWeightedRandomWordIndex();
                        recentWordHistory.push(currentWordIndex);
                        localStorage.setItem('recentWordHistory', JSON.stringify(recentWordHistory));
                        displayCurrentWord(allWords[currentWordIndex]);
                    }
                } else {
                    showMessage("No words available! Try submitting one.", false);
                }
            } catch (error) {
                console.error('Error fetching words:', error);
                if(updateDisplay) showMessage("Connection Error. Check API.", true);
            }
        }

        async function submitVote(voteType, fromSwipe = false) {
            if (isCoolingDown) {
                const remaining = Math.ceil((cooldownEndTime - Date.now()) / 1000);
                showCooldownMessage(remaining > 0 ? remaining : 0);
                return;
            }

            const now = Date.now();
            if (lastVoteTime > 0 && (now - lastVoteTime) > STREAK_WINDOW_MS) voteStreak = 0;
            lastVoteTime = now;

            if (voteStreak >= MASH_LIMIT) {
                mashCounter++;
                if (mashCounter >= 3) {
                    isCoolingDown = true;
                    cooldownEndTime = now + (COOLDOWN_SECONDS * 1000);
                    localStorage.setItem('cooldownEndTime', cooldownEndTime);
                    mashCounter = 0;
                    voteStreak = 0;
                    // Start countdown
                    cooldownTimer = setInterval(() => {
                        const remaining = Math.ceil((cooldownEndTime - Date.now()) / 1000);
                        if (remaining <= 0) {
                            clearInterval(cooldownTimer);
                            isCoolingDown = false;
                            nextWord();
                            fetchWords(false);
                            localStorage.removeItem('cooldownEndTime');
                        } else {
                            showCooldownMessage(remaining);
                        }
                    }, 1000);
                    showCooldownMessage(COOLDOWN_SECONDS);
                    return;
                }
            } else {
                voteStreak++;
            }
            
            if (currentWordIndex === -1 || !allWords[currentWordIndex]) {
                 console.error("No current word selected for voting.");
                 return;
            }

            const currentWord = allWords[currentWordIndex];
            const wordText = currentWord.text;

            goodButton.disabled = true;
            badButton.disabled = true;
            notWordButton.disabled = true;

            const isCake = wordText.toUpperCase() === BOOSTED_WORD;
            const isLlama = wordText.toUpperCase() === LLAMA_WORD;
            const isPotato = wordText.toUpperCase() === POTATO_WORD;
            const isSquirrel = wordText.toUpperCase() === SQUIRREL_WORD;

            try {
                // Determine animation type and duration
                const transitionDuration = 700; // milliseconds
                
                if (voteType === 'good' || voteType === 'bad') {
                    // Check if this word is a theme trigger and if it's new
                    const themeWasNewlyUnlocked = checkAndApplyTheme(wordText);
                    
                    // --- FIRE THEME PERFORMANCE FIX: Hide heavy fire effect during animation ---
                    // This is a re-implementation of the performance fix if needed, but the overflow-x:hidden should be enough for the reported bug.
                    const isFireBadVote = currentTheme === 'fire' && voteType === 'bad' && fireEffect;
                    if (isFireBadVote) {
                        fireEffect.classList.add('hidden'); 
                        setTimeout(() => {
                            if (currentTheme === 'fire') { 
                                fireEffect.classList.remove('hidden');
                            }
                        }, transitionDuration); 
                    }
                    // --- END FIRE THEME FIX ---

                    // Apply CSS animation class
                    wordDisplay.classList.add(`word-transition-${voteType}`);
                    // Use inline styles to ensure transition properties are removed from swipe transitions
                    wordDisplay.style.transition = 'none';
                    const animationName = voteType === 'good' ? 'slide-out-left-good' : 'slide-out-right-bad';
                    wordDisplay.style.animation = `${animationName} ${transitionDuration / 1000}s ease-out forwards`;
                }

                // --- Special Word Logic ---
                if (isCake) {
                    wordDisplay.classList.add('word-fade-quick');
                    updateSpecialBadges(currentWord.text);
                    setTimeout(() => {
                        wordDisplay.classList.remove('word-fade-quick');
                        wordDisplay.style.opacity = '1';
                        wordDisplay.style.transform = 'none';
                        showMessage("The cake is a lie!", false);
                        wordDisplay.style.fontSize = '1.5rem';
                        setTimeout(() => {
                            nextWord();
                            fetchWords(false);
                        }, CAKE_MESSAGE_DURATION);
                    }, CAKE_WORD_FADE_DURATION);
                    return;
                }
                
                if (isLlama) {
                    wordDisplay.classList.add('word-fade-llama');
                    updateSpecialBadges(currentWord.text);
                    setTimeout(() => {
                        wordDisplay.classList.remove('word-fade-llama');
                        wordDisplay.style.opacity = '1';
                        wordDisplay.style.transform = 'none';
                        showMessage("what llama?", false);
                        wordDisplay.style.fontSize = '1rem';
                        setTimeout(() => {
                            nextWord();
                            fetchWords(false);
                        }, 2000);
                    }, 8000);
                    return;
                }
                
                if (isPotato) {
                    wordDisplay.classList.add('word-fade-quick');
                    updateSpecialBadges(currentWord.text);
                    setTimeout(() => {
                        wordDisplay.classList.remove('word-fade-quick');
                        wordDisplay.style.opacity = '1';
                        wordDisplay.style.transform = 'none';
                        showMessage("Potatoes gonna potate.", false);
                        wordDisplay.style.fontSize = '1.5rem';
                        setTimeout(() => {
                            nextWord();
                            fetchWords(false);
                        }, 2000);
                    }, 300);
                    return;
                }

                if (isSquirrel) {
                    wordDisplay.classList.add('word-fade-quick');
                    updateSpecialBadges(currentWord.text);
                    setTimeout(() => {
                        wordDisplay.classList.remove('word-fade-quick');
                        wordDisplay.style.opacity = '1';
                        wordDisplay.style.transform = 'none';
                        showMessage("SQUIGGLE!", false);
                        wordDisplay.style.fontSize = '2.5rem';
                        setTimeout(() => {
                            nextWord();
                            fetchWords(false);
                        }, 2000);
                    }, 300);
                    return;
                }
                // --- End Special Word Logic ---

                const response = await fetch(`${API_BASE_URL}/vote`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ userId, wordId: currentWord.id, voteType })
                });

                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                
                const updatedWordData = await response.json();
                
                if (voteType !== 'notWord') {
                    voteCount++;
                    localStorage.setItem('voteCount', voteCount);
                }

                let awardAchieved = false;
                let awardName = '';
                let emoji = '';
                if (voteCount === 10) {
                    awardName = 'Bronze Star'; emoji = '‚≠ê'; awardAchieved = true;
                } else if (voteCount === 50) {
                    awardName = 'Silver Star'; emoji = '‚ú®'; awardAchieved = true;
                } else if (voteCount === 100) {
                    awardName = 'Gold Star'; emoji = 'üåü'; awardAchieved = true;
                } else if (voteCount === 250) {
                    awardName = 'Platinum Star'; emoji = 'üèÜ'; awardAchieved = true;
                }

                displayPostVoteMessage(updatedWordData, voteType, themeWasNewlyUnlocked, awardAchieved);

                if (themeWasNewlyUnlocked || awardAchieved) {
                    const messageToDisplay = themeWasNewlyUnlocked ? `'${currentTheme.charAt(0).toUpperCase() + currentTheme.slice(1)}' Theme` : awardName;
                    const emojiToDisplay = themeWasNewlyUnlocked ? 'üéÅ' : emoji;
                    showAwardMessageAndContinue(messageToDisplay, emojiToDisplay);
                } else {
                    const transitionDelay = (voteType === 'good' || voteType === 'bad') ? transitionDuration : 0;
                    setTimeout(() => {
                        nextWord();
                        fetchWords(false);
                    }, transitionDelay);
                }

            } catch (error) {
                console.error('Error submitting vote:', error);
                showMessage("Vote failed. Try again.", true);
                wordDisplay.classList.remove('word-transition-good', 'word-transition-bad', 'word-fade-cake', 'word-fade-quick');
                goodButton.disabled = false;
                badButton.disabled = false;
                notWordButton.disabled = false;
                voteStreak = 0;
            }
        }

        function getRankedWords(voteType, limit) {
            const sortedWords = allWords
                .filter(w => (w[voteType + 'Votes'] || 0) > 0)
                .sort((a, b) => (b[voteType + 'Votes'] || 0) - (a[voteType + 'Votes'] || 0));
            return sortedWords.slice(0, limit);
        }

        // --- MODAL FUNCTIONS ---

        function showModal() {
            submissionModal.classList.remove('hidden');
            submissionModal.classList.add('flex');
            newWordInput.value = '';
            modalMessage.textContent = '';
            newWordInput.focus();
        }

        function hideModal() {
            submissionModal.classList.remove('flex');
            submissionModal.classList.add('hidden');
        }

        async function submitCustomWord() {
            const word = newWordInput.value.trim();
            if (word.length < 2 || word.length > 30 || !/^[a-zA-Z]+$/.test(word)) {
                modalMessage.textContent = 'Word must be 2-30 letters long and contain only letters.';
                return;
            }

            modalMessage.textContent = 'Submitting...';

            try {
                const response = await fetch(`${API_BASE_URL}/submit`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ userId, text: word })
                });

                const result = await response.json();

                if (response.ok) {
                    modalMessage.textContent = `"${word.toUpperCase()}" submitted successfully!`;
                    contributorCount++;
                    localStorage.setItem('contributorCount', contributorCount);
                    updateContributorBadge();
                    setTimeout(() => {
                        hideModal();
                        fetchWords(false);
                    }, 1500);
                } else {
                    modalMessage.textContent = result.message || 'Submission failed. Word may already exist or is inappropriate.';
                }
            } catch (error) {
                console.error('Error submitting custom word:', error);
                modalMessage.textContent = 'Connection error. Please try again.';
            }
        }

        function showFullRankingsModal() {
            const rankedGood = getRankedWords('good', 100);
            const rankedBad = getRankedWords('bad', 100);

            fullGoodRankings.innerHTML = rankedGood.map((w, i) => 
                `<div class="flex justify-between items-center py-1 border-b text-sm">
                    <span class="font-medium text-gray-700">${i + 1}. ${w.text.toUpperCase()}</span>
                    <span class="text-green-600 font-bold">${w.goodVotes}</span>
                </div>`
            ).join('');

            fullBadRankings.innerHTML = rankedBad.map((w, i) => 
                `<div class="flex justify-between items-center py-1 border-b text-sm">
                    <span class="font-medium text-gray-700">${i + 1}. ${w.text.toUpperCase()}</span>
                    <span class="text-red-600 font-bold">${w.badVotes}</span>
                </div>`
            ).join('');

            fullRankingsModalContainer.classList.remove('hidden');
            fullRankingsModalContainer.classList.add('flex');
        }

        function hideFullRankingsModal() {
            fullRankingsModalContainer.classList.remove('flex');
            fullRankingsModalContainer.classList.add('hidden');
        }

        function showCompareModal() {
            compareModalContainer.classList.remove('hidden');
            compareModalContainer.classList.add('flex');
            wordOneInput.value = '';
            wordTwoInput.value = '';
            compareResults.innerHTML = 'Type words above to compare them!';
        }

        function hideCompareModal() {
            compareModalContainer.classList.remove('flex');
            compareModalContainer.classList.add('hidden');
        }

        function formatComparisonResult(word, position) {
            if (!word) return `<div class="text-red-500">Could not find data for Word ${position}.</div>`;
            const total = (word.goodVotes || 0) + (word.badVotes || 0);
            const goodPct = total > 0 ? ((word.goodVotes / total) * 100).toFixed(1) : 0;
            const badPct = total > 0 ? ((word.badVotes / total) * 100).toFixed(1) : 0;
            
            return `
                <div class="p-2 border rounded-lg shadow-sm">
                    <h4 class="text-xl font-bold mb-1 text-purple-700">${word.text.toUpperCase()}</h4>
                    <p class="text-sm">Total Votes: <span class="font-semibold">${total}</span></p>
                    <p class="text-sm text-green-600">Good: <span class="font-bold">${word.goodVotes || 0}</span> (${goodPct}%)</p>
                    <p class="text-sm text-red-600">Bad: <span class="font-bold">${word.badVotes || 0}</span> (${badPct}%)</p>
                </div>
            `;
        }

        function runComparison() {
            const wordOneText = wordOneInput.value.trim().toUpperCase();
            const wordTwoText = wordTwoInput.value.trim().toUpperCase();

            if (!wordOneText || !wordTwoText) {
                compareResults.innerHTML = '<div class="text-red-500">Please enter both words to compare.</div>';
                return;
            }

            const wordOne = allWords.find(w => w.text.toUpperCase() === wordOneText);
            const wordTwo = allWords.find(w => w.text.toUpperCase() === wordTwoText);

            if (!wordOne && !wordTwo) {
                compareResults.innerHTML = '<div class="text-red-500">Neither word could be found in the database.</div>';
                return;
            }

            let resultHtml = `
                <div class="grid grid-cols-2 gap-4">
                    ${formatComparisonResult(wordOne, 'One')}
                    ${formatComparisonResult(wordTwo, 'Two')}
                </div>
            `;

            if (wordOne && wordTwo) {
                const totalOne = (wordOne.goodVotes || 0) + (wordOne.badVotes || 0);
                const totalTwo = (wordTwo.goodVotes || 0) + (wordTwo.badVotes || 0);
                
                const goodPctOne = totalOne > 0 ? (wordOne.goodVotes / totalOne) : 0;
                const goodPctTwo = totalTwo > 0 ? (wordTwo.goodVotes / totalTwo) : 0;

                let comparisonText = '';
                if (Math.abs(goodPctOne - goodPctTwo) < 0.05) { // 5% difference threshold
                    comparisonText = 'These two words are rated almost exactly the same!';
                } else if (goodPctOne > goodPctTwo) {
                    comparisonText = `${wordOne.text.toUpperCase()} is considered a much better word than ${wordTwo.text.toUpperCase()}.`;
                } else {
                    comparisonText = `${wordTwo.text.toUpperCase()} is considered a much better word than ${wordOne.text.toUpperCase()}.`;
                }

                resultHtml += `<div class="mt-4 p-3 bg-purple-50 rounded-lg text-purple-800 font-semibold">${comparisonText}</div>`;
            }

            compareResults.innerHTML = resultHtml;
        }

        function showSettingsModal() {
            loadSettings();
            settingsModalContainer.classList.remove('hidden');
            settingsModalContainer.classList.add('flex');
        }

        function hideSettingsModal() {
            settingsModalContainer.classList.remove('flex');
            settingsModalContainer.classList.add('hidden');
        }

        // --- SWIPE LOGIC ---
        function handleTouchStart(evt) {
            if (isCoolingDown || isSpecialMessage || goodButton.disabled) return;
            isDragging = true;
            initialX = evt.touches[0].clientX;
            wordDisplay.style.transition = 'none'; // Disable CSS transitions for drag smoothness
            if (currentTheme === 'submarine' || currentTheme === 'banana' || currentTheme === 'rainbow' || currentTheme === 'summer') {
                wordDisplay.style.animation = 'none'; // Pause continuous theme animations
            }
        }

        function handleTouchMove(evt) {
            if (!isDragging) return;
            evt.preventDefault(); // Prevents vertical scrolling while dragging horizontally
            currentX = evt.touches[0].clientX;
            xOffset = currentX - initialX;
            const rotation = xOffset * 0.05;
            wordDisplay.style.transform = `translateX(${xOffset}px) rotate(${rotation}deg)`;
            
            // Visual feedback on drag
            if (xOffset < 0) {
                // Good Word (sliding left)
                wordDisplay.style.color = `rgba(16, 185, 129, ${0.5 + (Math.min(Math.abs(xOffset), 200)/400)})`;
            } else {
                // Bad Word (sliding right)
                wordDisplay.style.color = `rgba(239, 68, 68, ${0.5 + (Math.min(Math.abs(xOffset), 200)/400)})`;
            }
        }

        function handleTouchEnd(evt) {
            if (!isDragging) return;
            isDragging = false;
            
            if (Math.abs(xOffset) > SWIPE_THRESHOLD) {
                const voteType = xOffset > 0 ? 'bad' : 'good';
                // Set final animation trajectory for smooth finish off-screen
                const endX = xOffset > 0 ? window.innerWidth : -window.innerWidth;
                
                wordDisplay.style.transition = 'transform 0.5s ease-out, opacity 0.5s ease-out';
                wordDisplay.style.transform = `translateX(${endX}px) rotate(${xOffset * 0.1}deg)`;
                wordDisplay.style.opacity = '0';

                // Submit the vote and trigger the next word
                submitVote(voteType, true);

            } else {
                // Snap back
                wordDisplay.style.transition = 'transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275), color 0.3s';
                wordDisplay.style.transform = 'translateX(0px) rotate(0deg)';
                
                // Restore color and theme animation after snap
                setTimeout(() => {
                    wordDisplay.style.color = '';
                    if (currentTheme === 'submarine') {
                        wordDisplay.style.animation = 'bobbing-word 2.5s ease-in-out infinite';
                    } else if (currentTheme === 'banana') {
                        wordDisplay.style.animation = 'bounce-word 0.5s ease-out infinite alternate';
                    } else if (currentTheme === 'rainbow') {
                        wordDisplay.style.animation = 'rainbow-text 5s ease infinite';
                    } else if (currentTheme === 'summer') {
                        wordDisplay.style.animation = 'sun-glow 3s ease-in-out infinite';
                    }
                    displayCurrentWord(allWords[currentWordIndex]); // Re-apply theme color/style
                }, 300);
            }
            
            xOffset = 0; // Reset offset
        }
        
        // --- DEFINITION LOGIC ---
        function showDefinitionModal(wordText = null) {
            const word = wordText || (allWords[currentWordIndex] ? allWords[currentWordIndex].text : null);

            if (!word) return;

            definitionWord.textContent = word.toUpperCase();
            definitionResults.innerHTML = '<p class="text-gray-500">Loading definition...</p>';

            definitionModalContainer.classList.remove('hidden');
            definitionModalContainer.classList.add('flex');

            fetchDefinition(word);
        }

        async function fetchDefinition(word) {
            try {
                // Using a generic dictionary API endpoint (assuming one exists)
                const response = await fetch(`https://api.dictionaryapi.dev/api/v2/entries/en/${word}`);
                const data = await response.json();

                if (response.ok) {
                    definitionResults.innerHTML = formatDefinitionHtml(data);
                } else {
                    definitionResults.innerHTML = `<p class="text-red-500">Sorry, no definition was found for "${word}".</p>`;
                }
            } catch (error) {
                console.error('Error fetching definition:', error);
                definitionResults.innerHTML = '<p class="text-red-500">An error occurred while fetching the definition.</p>';
            }
        }

        function hideDefinitionModal() { definitionModalContainer.classList.remove('flex'); definitionModalContainer.classList.add('hidden'); }

        function formatDefinitionHtml(data) {
            if (!data || data.length === 0 || data.title === "No Definitions Found") return '<p class="text-red-500">Sorry, no definition was found.</p>';
            let html = '';
            const wordData = Array.isArray(data) ? data[0] : data; 

            // Handle phonetics
            const phonetic = wordData.phonetic || (wordData.phonetics && wordData.phonetics.length > 0 ? wordData.phonetics[0].text : '');
            if (phonetic) {
                html += `<p class="text-md text-gray-700 mb-4 font-mono">${phonetic}</p>`;
            }

            wordData.meanings.forEach(meaning => {
                html += `<div class="mb-4"><h4 class="text-lg font-bold italic text-indigo-600">${meaning.partOfSpeech}</h4>`;
                html += '<ol class="list-decimal list-inside pl-4 mt-2 space-y-1">';
                meaning.definitions.forEach(def => {
                    html += `<li>${def.definition}</li>`;
                    if (def.example) html += `<p class="text-sm text-gray-500 pl-4 italic">"${def.example}"</p>`;
                });
                html += '</ol></div>';
            });
            return html;
        }
        
        // --- INITIALIZATION ---
        
        window.loadCakeWord = loadCakeWord;
        window.loadLlamaWord = loadLlamaWord;
        window.loadPotatoWord = loadPotatoWord;
        window.loadSquirrelWord = loadSquirrelWord;
        window.applyTheme = applyTheme; // Expose to global scope for theme testing

        checkStorage();
        loadSettings();
        populateThemeChooser();
        applyTheme(currentTheme);

        // Event Listeners
        versionIndicator.innerHTML = `v${APP_VERSION} | Made by <a href="mailto:gileswendes@gmail.com">Gilxs</a> in 12,025`;

        goodButton.addEventListener('click', () => submitVote('good'));
        badButton.addEventListener('click', () => submitVote('bad'));
        notWordButton.addEventListener('click', () => submitVote('notWord'));
        customWordButton.addEventListener('click', () => showModal());
        cancelSubmitButton.addEventListener('click', () => hideModal());
        submitWordButton.addEventListener('click', submitCustomWord);
        showTop100Button.addEventListener('click', showFullRankingsModal);
        closeFullRankingsModal.addEventListener('click', hideFullRankingsModal);
        fullRankingsModalContainer.addEventListener('click', (e) => { 
            if (e.target === fullRankingsModalContainer) { hideFullRankingsModal(); } 
        });

        // DRAG & SWIPE EVENT LISTENERS
        gameCard.addEventListener('touchstart', handleTouchStart, false);
        gameCard.addEventListener('touchmove', handleTouchMove, { passive: false });
        gameCard.addEventListener('touchend', handleTouchEnd, false);

        wordDisplay.addEventListener('click', showDefinitionModal);
        closeDefinitionModal.addEventListener('click', hideDefinitionModal);
        definitionModalContainer.addEventListener('click', (e) => { 
            if (e.target === definitionModalContainer) { hideDefinitionModal(); } 
        });

        compareWordsButton.addEventListener('click', showCompareModal);
        closeCompareModal.addEventListener('click', hideCompareModal);
        compareModalContainer.addEventListener('click', (e) => { 
            if (e.target === compareModalContainer) { hideCompareModal(); } 
        });
        runComparisonButton.addEventListener('click', runComparison);

        showSettingsButton.addEventListener('click', showSettingsModal);
        closeSettingsModal.addEventListener('click', hideSettingsModal);
        settingsModalContainer.addEventListener('click', (e) => { 
            if (e.target === settingsModalContainer) { hideSettingsModal(); } 
        });
        togglePercentages.addEventListener('change', updateSettings);
        toggleTips.addEventListener('change', updateSettings);
        clearAllDataButton.addEventListener('click', clearAllLocalData);

        // Badge Listeners
        cakeBadge.addEventListener('click', loadCakeWord);
        llamaBadge.addEventListener('click', loadLlamaWord);
        potatoBadge.addEventListener('click', loadPotatoWord);
        squirrelBadge.addEventListener('click', loadSquirrelWord);
        
        // Stats Badge Listeners
        awardBadge.addEventListener('click', () => showStatsMessage('award'));
        contributorBadge.addEventListener('click', () => showStatsMessage('contributor'));

        themeChooser.addEventListener('change', (e) => {
            applyTheme(e.target.value);
            // Re-display current word to apply new theme styles
            displayCurrentWord(allWords[currentWordIndex]); 
        });


        // Initial data fetch
        fetchWords();

        // Check for cooling down status on load
        if (cooldownEndTime > Date.now()) {
            isCoolingDown = true;
            const remaining = Math.ceil((cooldownEndTime - Date.now()) / 1000);
            showCooldownMessage(remaining);
            cooldownTimer = setInterval(() => {
                const remaining = Math.ceil((cooldownEndTime - Date.now()) / 1000);
                if (remaining <= 0) {
                    clearInterval(cooldownTimer);
                    isCoolingDown = false;
                    nextWord();
                    fetchWords(false);
                    localStorage.removeItem('cooldownEndTime');
                } else {
                    showCooldownMessage(remaining);
                }
            }, 1000);
        }

    </script>
</body>
</html>
