Gemini
Enhance Game Word Selection Logic
Create Local User Accounts in Windows
Browser Game: Good Word / Bad Word
design a fun logo using the text 'GOOD WORD / BAD WORD' with a height of 64 pixels an a fluid width of 448 pixels
Deploy Logic Pro Sound Files with Jamf
Browser Game Concept: Good Word/Bad Word
PowerShell Script Detects Device Removal
School Internet Browser Acceptable Use Policy
A Flag Lover's Vexillology Chat
Account Switching Deactivated: Causes & Solutions
Pong Game in HTML
Prevent Computer Locking and Sleep
Understanding the Word 'Twill'
PowerPoint 'H' Key Not Working
Vague Instructions Lead To Inaction
SCCM Query for Computer Names
PowerShell Detect Keyboard Unplugged
Troubleshooting Edge Multiple Blank Tabs
Concern and Reassurance Needed
Naming Characters for Murder Mystery
Character Count Request Awaits Path
UK Girls' Names, Town Matches
Swiss Cottage Job Market Overview
EV Sales Growth Slowing
Kilos Purchased for Given Price
Make this into a spreadsheet
Summer Staff BBQ Games
UK vs. US Income Taxes
2FA for UK School
Delegate Student Password Reset
Days in Each Month
Modify Script for Profile Deletion
Create Users from CSV
Safe User Deletion Script
Commonality Between Gemma and a Duck
Conversation with Gemini
The logic for this game needs to be more random, it's showing the same words too many times. Can words with the fewest votes be shown first?

That's a great request to improve the randomness and exposure of less-voted words! Changing the word selection logic to prioritize words with fewer votes will help broaden the player's experience.

You need to modify the fetchWords function and the word selection logic within nextWord and displayCurrentWord (when initially setting the word).

Here are the changes you should make in the provided JavaScript:

1. Update fetchWords to Store the Raw List
You already fetch all words, but the logic for picking the next word should use a list sorted by vote count to prioritize low-voted words. Since you get an unsorted list from the API and need to know the total votes for each, we'll keep the current setup but change how the initial word is picked.

2. Modify fetchWords for Initial Word Selection
We'll change the initial word selection in fetchWords to look for the word with the lowest total vote count (Good + Bad + Not Word).

JavaScript
// Locate this section in fetchWords:
// ...
                if (allWords.length > 0) {
                    updateStatsAndRankings();
                    
                    if (updateDisplay) {
                        currentWordIndex = Math.floor(Math.random() * allWords.length);
                        displayCurrentWord();
                    } 
// ...

// And replace it with this updated logic:
                if (allWords.length > 0) {
                    updateStatsAndRankings();
                    
                    if (updateDisplay) {
                        // --- NEW LOGIC: Select a word with the fewest votes initially ---
                        const wordsWithVoteCounts = allWords.map((w, index) => ({
                            index,
                            totalVotes: (w.goodVotes || 0) + (w.badVotes || 0) + (w.notWordVotes || 0)
                        }));

                        // Find the minimum vote count
                        const minVotes = wordsWithVoteCounts.reduce((min, w) => Math.min(min, w.totalVotes), Infinity);
                        
                        // Filter for all words with that minimum vote count
                        const lowestVotedWords = wordsWithVoteCounts.filter(w => w.totalVotes === minVotes);
                        
                        // Randomly select one of the lowest-voted words
                        const selectedWord = lowestVotedWords[Math.floor(Math.random() * lowestVotedWords.length)];
                        currentWordIndex = selectedWord.index;
                        
                        // ----------------------------------------------------------------
                        displayCurrentWord();
                    } 
                } else {
                    showMessage("No words available! Try submitting one.", false);
                }
// ...
3. Modify nextWord for Continuous Low-Vote Priority
The nextWord function currently picks a word completely at random. We will update it to implement a hybrid approach: always select from the lowest-voted words, similar to the initial selection logic.

Find the nextWord function:

JavaScript
function nextWord() {
    if (allWords.length === 0) return;
    
    let nextIndex;
    do {
        nextIndex = Math.floor(Math.random() * allWords.length);
    } while (nextIndex === currentWordIndex && allWords.length > 1);
    
    currentWordIndex = nextIndex;
    displayCurrentWord();
}
And replace the logic inside it with the new low-vote priority logic:

JavaScript
function nextWord() {
    if (allWords.length === 0) return;
    
    // --- NEW LOGIC: Select a word with the fewest votes, excluding the current one ---
    const wordsWithVoteCounts = allWords
        .map((w, index) => ({
            index,
            totalVotes: (w.goodVotes || 0) + (w.badVotes || 0) + (w.notWordVotes || 0)
        }))
        .filter(w => w.index !== currentWordIndex); // Exclude the word just voted on

    if (wordsWithVoteCounts.length === 0) {
        // If only one word remains, just re-display it (though this is unlikely)
        displayCurrentWord();
        return;
    }

    // Find the minimum vote count among the remaining words
    const minVotes = wordsWithVoteCounts.reduce((min, w) => Math.min(min, w.totalVotes), Infinity);
    
    // Filter for all words with that minimum vote count
    const lowestVotedWords = wordsWithVoteCounts.filter(w => w.totalVotes === minVotes);
    
    // Randomly select one of the lowest-voted words
    const selectedWord = lowestVotedWords[Math.floor(Math.random() * lowestVotedWords.length)];
    currentWordIndex = selectedWord.index;
    
    // ----------------------------------------------------------------
    displayCurrentWord();
}
These changes ensure that both the first word shown and every subsequent word are chosen from the pool of words with the fewest total votes, making the game much more likely to surface less-voted content.

can you do this?

Yes, I can certainly implement the requested logic to prioritize words with fewer votes and increase randomness! This will ensure that all words in the database get more exposure.

Here are the specific modifications to the JavaScript code:

Updated JavaScript Logic
I've modified the fetchWords function (for the initial load) and the nextWord function (for continuous play) to use a Lowest-Vote Priority selection method.

Find the following two functions in your index (1).html file and replace them entirely with the code below:

1. The fetchWords Function (Initial Load)
This change ensures that the very first word displayed when the game loads is one of the words with the lowest total votes (Good + Bad + Not Word).

JavaScript
// Function: fetchWords
async function fetchWords(updateDisplay = true) {
    try {
        if(updateDisplay) {
            showMessage("Loading words...", false);
        }
        const response = await fetch(API_BASE_URL);
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        let fetchedWords = await response.json();
        
        // Filter out words that are too far gone (3 or more "Not a word!" votes)
        const availableWords = fetchedWords.filter(w => (w.notWordVotes || 0) < 3);
        allWords = availableWords;
        
        // Update word count regardless of whether the display is updated
        wordCount.textContent = `Words in Database: ${fetchedWords.length}`;
        
        if (allWords.length > 0) {
            updateStatsAndRankings();
            
            if (updateDisplay) {
                // --- MODIFIED LOGIC: Select a word with the fewest votes initially ---
                const wordsWithVoteCounts = allWords.map((w, index) => ({
                    index,
                    totalVotes: (w.goodVotes || 0) + (w.badVotes || 0) + (w.notWordVotes || 0)
                }));

                // Find the minimum vote count
                const minVotes = wordsWithVoteCounts.reduce((min, w) => Math.min(min, w.totalVotes), Infinity);
                
                // Filter for all words with that minimum vote count
                const lowestVotedWords = wordsWithVoteCounts.filter(w => w.totalVotes === minVotes);
                
                // Randomly select one of the lowest-voted words (to maintain randomness among low-voted words)
                const selectedWord = lowestVotedWords[Math.floor(Math.random() * lowestVotedWords.length)];
                currentWordIndex = selectedWord.index;
                // ----------------------------------------------------------------
                
                displayCurrentWord();
            } 
        } else {
            showMessage("No words available! Try submitting one.", false);
        }

    } catch (error) {
        console.error('Error fetching words:', error);
        if(updateDisplay) {
            showMessage("Connection Error. Check your API URL.", true);
        }
    }
}
2. The nextWord Function (Continuous Play)
This change implements the Lowest-Vote Priority for all subsequent words. It randomly picks from the pool of words that currently have the fewest total votes, ensuring better word distribution and randomness among that pool.

JavaScript
// Function: nextWord
function nextWord() {
    if (allWords.length === 0) return;
    
    // --- MODIFIED LOGIC: Select a word with the fewest votes, excluding the current one ---
    const wordsWithVoteCounts = allWords
        .map((w, index) => ({
            index,
            totalVotes: (w.goodVotes || 0) + (w.badVotes || 0) + (w.notWordVotes || 0)
        }))
        .filter(w => w.index !== currentWordIndex); // Exclude the word just voted on

    if (wordsWithVoteCounts.length === 0) {
        // If only one word remains, just re-display it
        displayCurrentWord();
        return;
    }

    // Find the minimum vote count among the remaining words
    const minVotes = wordsWithVoteCounts.reduce((min, w) => Math.min(min, w.totalVotes), Infinity);
    
    // Filter for all words with that minimum vote count
    const lowestVotedWords = wordsWithVoteCounts.filter(w => w.totalVotes === minVotes);
    
    // Randomly select one of the lowest-voted words
    const selectedWord = lowestVotedWords[Math.floor(Math.random() * lowestVotedWords.length)];
    currentWordIndex = selectedWord.index;
    
    // ----------------------------------------------------------------
    displayCurrentWord();
}
please add these changes to the index.html file

Here is the complete, updated content for your index.html file with the logic changes applied.

I've replaced the original fetchWords and nextWord functions with the new versions that prioritize words with the fewest total votes for selection.

HTML
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GOOD WORD / BAD WORD</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&display=swap" rel="stylesheet">
    <style>
        body { 
            font-family: 'Inter', sans-serif; 
            background: linear-gradient(135deg, #f0fff0 0%, #e0f7fa 100%);
        }
        .card { 
            backdrop-filter: blur(10px); 
            background-color: rgba(255, 255, 255, 0.95);
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.15);
            border: 1px solid rgba(0, 0, 0, 0.05);
            transition: transform 0.2s ease-out, box-shadow 0.2s ease-out;
        }
        #gameCard:hover {
            transform: translateY(-4px);
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.2);
        }
        .good-button { background: linear-gradient(145deg, #10b981, #059669); }
        .bad-button { background: linear-gradient(145deg, #ef4444, #dc2626); }
        .not-word-button { background: linear-gradient(145deg, #64748b, #475569); }
        button { transition: transform 0.1s ease, box-shadow 0.1s ease; }
        button:active { transform: scale(0.98); box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2); }
        
        /* Centered Version Indicator */
        .version-indicator { 
            position: fixed; 
            bottom: 5px; 
            left: 50%; 
            transform: translateX(-50%); 
            font-size: 0.75rem; 
            color: #9ca3af; 
            z-index: 50; 
        }
        /* Style for the Cake Message */
        #cakeMessage {
            font-size: 1.125rem; /* text-xl */
            font-weight: 700; /* font-bold */
            color: #4b5563; /* text-gray-700 */
            margin-top: -1.5rem; /* -mt-6 (Tailwind unit 6 = 1.5rem) */
            margin-bottom: 1rem; /* mb-4 (Tailwind unit 4 = 1rem) */
            opacity: 0;
            transition: opacity 0.3s ease-in-out;
        }
        .opacity-100 { opacity: 1; }

        @media (max-width: 640px) {
            .rank-item { font-size: 0.8rem; }
            .vote-counts { font-size: 0.875rem; }
        }

        /* --- ANIMATION STYLES --- */
        .word-transition-good {
            animation: slide-out-left-good 0.4s ease-out forwards;
        }
        .word-transition-bad {
            animation: slide-out-right-bad 0.4s ease-out forwards;
        }

        @keyframes slide-out-left-good {
            0% { 
                transform: translateX(0); 
                opacity: 1; 
                color: #111827; /* text-gray-900 */
            }
            100% { 
                transform: translateX(-150%); 
                opacity: 0; 
                color: #10b981; /* bg-green-500 */
            }
        }
        
        @keyframes slide-out-right-bad {
            0% { 
                transform: translateX(0); 
                opacity: 1; 
                color: #111827; /* text-gray-900 */
            }
            100% { 
                transform: translateX(150%); 
                opacity: 0; 
                color: #ef4444; /* bg-red-500 */
            }
        }
        /* ----------------------------------------------------- */

        /* --- FONT RESIZING FIX --- */
        #wordDisplay {
            font-size: 6rem; /* Default size, will be overwritten */
            white-space: nowrap; 
            overflow: hidden;
            max-width: 100%; 
            padding: 0 1rem; 
            box-sizing: border-box;
        }
        /* Full rankings modal specific styles */
        #fullRankingsModal {
            max-width: 800px;
            max-height: 90vh;
            overflow-y: auto;
        }
        .full-ranking-item {
            border-bottom: 1px solid #e5e7eb;
        }
    </style>
</head>
<body class="flex flex-col items-center justify-center min-h-screen p-4">

    <header class="text-center mb-8 w-full max-w-lg">
        <div id="logoArea" class="h-32 w-full flex items-center justify-center mb-4 relative">
            <img 
                src="logo.png" 
                alt="Good Word / Bad Word Logo with Rainbow and Devil" 
                class="h-full w-auto max-w-full"
            >
            <div id="awardBadge" class="absolute top-2 right-2 p-2 cursor-help text-3xl">
                </div>
        </div>
        <div class="mt-4 flex justify-around p-3 rounded-t-xl bg-white shadow-md vote-counts">
            <div id="goodTotal" class="text-xl font-bold text-green-600">GOOD: 0</div>
            <div id="badTotal" class="text-xl font-bold text-red-600">BAD: 0</div>
        </div>
        <div class="flex justify-center p-2 rounded-b-xl bg-gray-50 shadow-md">
            <div id="wordCount" class="text-sm font-semibold text-gray-500">
                Words in Database: 0
            </div>
        </div>
    </header>

    <main id="gameCard" class="card p-8 w-full max-w-sm flex flex-col items-center rounded-2xl">
        <div id="wordDisplay" class="font-extrabold text-gray-900 mb-8 text-center min-h-[72px]">
            Loading...
        </div>
        <div id="cakeMessage" class="text-center">
            </div>
        
        <div class="flex space-x-4 w-full mb-3">
            <button id="goodButton" class="good-button flex-1 py-4 text-white text-lg font-bold rounded-xl shadow-lg hover:shadow-xl focus:outline-none focus:ring-4 focus:ring-green-500/50" disabled>
                Good Word
            </button>
            <button id="badButton" class="bad-button flex-1 py-4 text-white text-lg font-bold rounded-xl shadow-lg hover:shadow-xl focus:outline-none focus:ring-4 focus:ring-red-500/50" disabled>
                Bad Word
            </button>
        </div>
        <button id="notWordButton" class="not-word-button w-full py-3 text-white text-lg font-bold rounded-xl shadow-lg hover:shadow-xl focus:outline-none focus:ring-4 focus:ring-slate-500/50" disabled>
            Not a word!
        </button>
        <button id="customWordButton" class="mt-4 text-sm text-gray-600 hover:text-gray-900 transition duration-150">
            Submit Custom Word
        </button>
    </main>

    <section class="mt-8 w-full max-w-4xl grid grid-cols-1 md:grid-cols-2 gap-8">
        <div class="card p-6 rounded-xl">
            <h2 class="text-xl font-bold text-green-700 mb-4 border-b pb-2">Top Good Words (Good > Bad)</h2>
            <div id="goodRankings" class="space-y-2">
                <p class="text-gray-500">No data yet.</p>
            </div>
        </div>
        <div class="card p-6 rounded-xl">
            <h2 class="text-xl font-bold text-red-700 mb-4 border-b pb-2">Top Bad Words (Bad > Good)</h2>
            <div id="badRankings" class="space-y-2">
                <p class="text-gray-500">No data yet.</p>
            </div>
        </div>
    </section>
    
    <div class="mt-6 w-full max-w-4xl text-center">
        <button id="showTop100Button" class="px-6 py-2 bg-blue-600 text-white font-bold rounded-lg shadow-md hover:bg-blue-700 transition duration-150">
            Show Top 100 Rankings
        </button>
    </div>

    <div id="submissionModal" class="fixed inset-0 bg-gray-900 bg-opacity-75 hidden items-center justify-center p-4 z-50">
        <div class="bg-white p-6 rounded-xl w-full max-w-md shadow-2xl">
            <h2 class="text-2xl font-bold mb-4">Submit a New Word</h2>
            <input type="text" id="newWordInput" placeholder="Enter your word here..." class="w-full p-3 border border-gray-300 rounded-lg mb-4 focus:ring-2 focus:ring-indigo-500">
            <div id="modalMessage" class="text-sm text-red-500 mb-4"></div>
            <div class="flex justify-end space-x-3">
                <button id="cancelSubmitButton" class="px-4 py-2 bg-gray-200 text-gray-700 font-medium rounded-lg hover:bg-gray-300 transition">
                    Cancel
                </button>
                <button id="submitWordButton" class="px-4 py-2 bg-indigo-600 text-white font-medium rounded-lg hover:bg-indigo-700 transition">
                    Submit Word
                </button>
            </div>
        </div>
    </div>
    
    <div id="fullRankingsModalContainer" class="fixed inset-0 bg-gray-900 bg-opacity-75 hidden items-center justify-center p-4 z-50">
        <div id="fullRankingsModal" class="bg-white p-6 rounded-xl w-full shadow-2xl">
            <div class="flex justify-between items-center mb-4 border-b pb-2">
                <h2 class="text-2xl font-bold">Top 100 Word Rankings</h2>
                <button id="closeFullRankingsModal" class="text-gray-500 hover:text-gray-800 text-2xl font-bold leading-none">
                    &times;
                </button>
            </div>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                <div>
                    <h3 class="text-lg font-semibold text-green-700 mb-2">Top Good Words</h3>
                    <div id="fullGoodRankings" class="space-y-1">
                        </div>
                </div>
                <div>
                    <h3 class="text-lg font-semibold text-red-700 mb-2">Top Bad Words</h3>
                    <div id="fullBadRankings" class="space-y-1">
                        </div>
                </div>
            </div>
        </div>
    </div>


    <div class="version-indicator">
        v3.3.2 | Made by Gilxs in 12,025
    </div>

    <script>
        const API_BASE_URL = '/api/words';
        // --- UPDATED VERSION ---
        const APP_VERSION = '3.3.2'; 

        let allWords = [];
        let currentWordIndex = 0;
        let userId = localStorage.getItem('userId');
        let voteCount = 0; 
        
        let voteStreak = 0;
        const MASH_LIMIT = 10;
        const COOLDOWN_SECONDS = 10;
        const STREAK_WINDOW_MS = 1500; 
        let cooldownTimer = null;
        let isCoolingDown = false;
        let lastVoteTime = 0; 

        const wordDisplay = document.getElementById('wordDisplay');
        const cakeMessage = document.getElementById('cakeMessage');
        const goodButton = document.getElementById('goodButton');
        const badButton = document.getElementById('badButton');
        const notWordButton = document.getElementById('notWordButton');
        const goodTotal = document.getElementById('goodTotal');
        const badTotal = document.getElementById('badTotal');
        const wordCount = document.getElementById('wordCount'); // New element
        const goodRankingsDiv = document.getElementById('goodRankings');
        const badRankingsDiv = document.getElementById('badRankings');
        const submissionModal = document.getElementById('submissionModal');
        const newWordInput = document.getElementById('newWordInput');
        const modalMessage = document.getElementById('modalMessage');
        const submitWordButton = document.getElementById('submitWordButton');
        const cancelSubmitButton = document.getElementById('cancelSubmitButton');
        const customWordButton = document.getElementById('customWordButton');
        const versionIndicator = document.querySelector('.version-indicator');
        const awardBadge = document.getElementById('awardBadge');
        const showTop100Button = document.getElementById('showTop100Button');
        const fullRankingsModalContainer = document.getElementById('fullRankingsModalContainer');
        const closeFullRankingsModal = document.getElementById('closeFullRankingsModal');
        const fullGoodRankingsDiv = document.getElementById('fullGoodRankings');
        const fullBadRankingsDiv = document.getElementById('fullBadRankings');

        function init() {
            if (!userId) {
                userId = crypto.randomUUID();
                localStorage.setItem('userId', userId);
            }
            
            const storedVoteCount = localStorage.getItem('voteCount');
            if (storedVoteCount) {
                voteCount = parseInt(storedVoteCount, 10);
            }

            versionIndicator.textContent = `v${APP_VERSION} | Made by Gilxs in 12,025`;
            
            goodButton.addEventListener('click', () => submitVote('good'));
            badButton.addEventListener('click', () => submitVote('bad'));
            notWordButton.addEventListener('click', () => submitVote('notWord'));
            customWordButton.addEventListener('click', () => showModal());
            cancelSubmitButton.addEventListener('click', () => hideModal());
            submitWordButton.addEventListener('click', submitCustomWord);
            
            // New Full Rankings button listeners
            showTop100Button.addEventListener('click', showFullRankingsModal);
            closeFullRankingsModal.addEventListener('click', hideFullRankingsModal);
            fullRankingsModalContainer.addEventListener('click', (e) => {
                if (e.target === fullRankingsModalContainer) {
                    hideFullRankingsModal();
                }
            });

            fetchWords();
            updateAwardBadge();
            
            window.addEventListener('resize', () => {
                if (allWords.length > 0) {
                    displayCurrentWord(); 
                }
            });
        }

        function updateAwardBadge() {
            let star = '';
            let title = '';
            
            if (voteCount >= 50) {
                star = 'ðŸŒŸ'; // Gold
                title = `Gold Star Award! (${voteCount} Votes)`;
            } else if (voteCount >= 25) {
                star = 'ðŸ¥ˆ'; // Silver
                title = `Silver Star Award! (${voteCount} Votes)`;
            } else if (voteCount >= 5) {
                star = 'ðŸ¥‰'; // Bronze
                title = `Bronze Star Award! (${voteCount} Votes)`;
            } else {
                star = 'âœ¨'; // Placeholder for progress
                title = `Votes: ${voteCount}. Next Award: Bronze (5 Votes)`;
            }

            awardBadge.textContent = star;
            awardBadge.title = title;
        }
        
        function showAwardMessageAndContinue(awardName, emoji) {
            wordDisplay.textContent = `${emoji} ${awardName} Unlocked! ${emoji}`;
            wordDisplay.className = 'text-4xl font-extrabold text-green-700 mb-8 text-center min-h-[72px] animate-pulse';
            wordDisplay.style.fontSize = '2.25rem'; 

            cakeMessage.classList.remove('opacity-100');
            cakeMessage.classList.add('opacity-0');
            cakeMessage.textContent = ''; 

            goodButton.disabled = true;
            badButton.disabled = true;
            notWordButton.disabled = true;

            setTimeout(() => {
                wordDisplay.classList.remove('animate-pulse');
                nextWord(); 
                fetchWords(false);
            }, 2500);
        }

        function showMessage(text, isError = false) {
            wordDisplay.textContent = text;
            wordDisplay.className = `text-4xl font-bold text-center mb-8 min-h-[72px] ${isError ? 'text-red-500' : 'text-gray-500'}`;
            wordDisplay.style.fontSize = '1.5rem'; 

            goodButton.disabled = true;
            badButton.disabled = true;
            notWordButton.disabled = true;

            cakeMessage.classList.remove('opacity-100');
            cakeMessage.classList.add('opacity-0');
            cakeMessage.textContent = '';
        }
        
        function showCooldownMessage(remainingSeconds) {
            wordDisplay.textContent = `Button mashing will not be tolerated. Wait ${remainingSeconds}s...`;
            wordDisplay.className = 'text-4xl font-bold text-red-600 mb-8 text-center min-h-[72px]';
            wordDisplay.style.fontSize = '1.5rem'; 
            
            goodButton.disabled = true;
            badButton.disabled = true;
            notWordButton.disabled = true;

            cakeMessage.classList.remove('opacity-100');
            cakeMessage.classList.add('opacity-0');
            cakeMessage.textContent = '';
        }

        function displayCurrentWord() {
            if (allWords.length === 0) {
                showMessage("No words available! Try submitting one.", false);
                return;
            }
            
            const currentWord = allWords[currentWordIndex];
            const wordText = currentWord.text.toUpperCase();
            
            // 1. Ensure no animation class is present before displaying the new word
            wordDisplay.classList.remove('word-transition-good', 'word-transition-bad');
            
            // 2. Set the word content and base classes
            wordDisplay.textContent = wordText;
            wordDisplay.className = 'font-extrabold text-gray-900 mb-8 text-center min-h-[72px]';
            
            // 3. Dynamic Font Sizing Logic
            const cardWidth = document.getElementById('gameCard').clientWidth - 64; 
            const maxFontSize = 96; 
            
            wordDisplay.style.fontSize = `${maxFontSize}px`;
            wordDisplay.style.whiteSpace = 'nowrap';

            let currentWidth = wordDisplay.scrollWidth;
            let finalFontSize = maxFontSize;

            if (currentWidth > cardWidth) {
                const scaleFactor = cardWidth / currentWidth;
                finalFontSize = Math.floor(maxFontSize * scaleFactor);
                if (finalFontSize < 24) finalFontSize = 24; 
            }
            
            wordDisplay.style.fontSize = `${finalFontSize}px`;
            wordDisplay.style.whiteSpace = 'normal'; 
            
            // 4. Check for the "cake" Easter Egg
            if (wordText === 'CAKE') {
                cakeMessage.textContent = 'The cake is a lie!';
                cakeMessage.classList.remove('opacity-0');
                cakeMessage.classList.add('opacity-100');
            } else {
                cakeMessage.classList.remove('opacity-100');
                cakeMessage.classList.add('opacity-0');
                cakeMessage.textContent = ''; 
            }
            
            goodButton.disabled = false;
            badButton.disabled = false;
            notWordButton.disabled = false;
        }

        // --- MODIFIED nextWord FUNCTION (Prioritizes Lowest Voted Words) ---
        function nextWord() {
            if (allWords.length === 0) return;
            
            // Logic: Select a word with the fewest votes, excluding the current one
            const wordsWithVoteCounts = allWords
                .map((w, index) => ({
                    index,
                    totalVotes: (w.goodVotes || 0) + (w.badVotes || 0) + (w.notWordVotes || 0)
                }))
                .filter(w => w.index !== currentWordIndex); // Exclude the word just voted on

            if (wordsWithVoteCounts.length === 0) {
                // If only one word remains, just re-display it
                displayCurrentWord();
                return;
            }

            // Find the minimum vote count among the remaining words
            const minVotes = wordsWithVoteCounts.reduce((min, w) => Math.min(min, w.totalVotes), Infinity);
            
            // Filter for all words with that minimum vote count
            const lowestVotedWords = wordsWithVoteCounts.filter(w => w.totalVotes === minVotes);
            
            // Randomly select one of the lowest-voted words (maintaining randomness)
            const selectedWord = lowestVotedWords[Math.floor(Math.random() * lowestVotedWords.length)];
            currentWordIndex = selectedWord.index;
            
            displayCurrentWord();
        }
        // ----------------------------------------------------------------------


        // --- MODIFIED fetchWords FUNCTION (Prioritizes Lowest Voted Word on Load) ---
        async function fetchWords(updateDisplay = true) {
            try {
                if(updateDisplay) {
                    showMessage("Loading words...", false);
                }
                const response = await fetch(API_BASE_URL);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                let fetchedWords = await response.json();
                
                const availableWords = fetchedWords.filter(w => (w.notWordVotes || 0) < 3);
                allWords = availableWords;
                
                // Update word count regardless of whether the display is updated
                wordCount.textContent = `Words in Database: ${fetchedWords.length}`;
                
                if (allWords.length > 0) {
                    updateStatsAndRankings();
                    
                    if (updateDisplay) {
                        // Logic: Select a word with the fewest votes initially
                        const wordsWithVoteCounts = allWords.map((w, index) => ({
                            index,
                            totalVotes: (w.goodVotes || 0) + (w.badVotes || 0) + (w.notWordVotes || 0)
                        }));

                        // Find the minimum vote count
                        const minVotes = wordsWithVoteCounts.reduce((min, w) => Math.min(min, w.totalVotes), Infinity);
                        
                        // Filter for all words with that minimum vote count
                        const lowestVotedWords = wordsWithVoteCounts.filter(w => w.totalVotes === minVotes);
                        
                        // Randomly select one of the lowest-voted words
                        const selectedWord = lowestVotedWords[Math.floor(Math.random() * lowestVotedWords.length)];
                        currentWordIndex = selectedWord.index;
                        
                        // ----------------------------------------------------------------
                        displayCurrentWord();
                    } 
                } else {
                    showMessage("No words available! Try submitting one.", false);
                }

            } catch (error) {
                console.error('Error fetching words:', error);
                if(updateDisplay) {
                    showMessage("Connection Error. Check your API URL.", true);
                }
            }
        }
        // ----------------------------------------------------------------------

        async function submitVote(voteType) {
            if (isCoolingDown) {
                const remaining = Math.ceil((cooldownEndTime - Date.now()) / 1000);
                showCooldownMessage(remaining > 0 ? remaining : 0);
                return;
            }

            const now = Date.now();
            if (lastVoteTime > 0 && (now - lastVoteTime) > STREAK_WINDOW_MS) {
                voteStreak = 1; 
            } else {
                voteStreak++; 
            }
            lastVoteTime = now; 

            if (voteStreak > MASH_LIMIT) {
                isCoolingDown = true;
                voteStreak = 0; 
                
                let remaining = COOLDOWN_SECONDS;
                const cooldownEndTime = Date.now() + COOLDOWN_SECONDS * 1000;

                showCooldownMessage(remaining);

                cooldownTimer = setInterval(() => {
                    remaining--;
                    if (remaining > 0) {
                        showCooldownMessage(remaining);
                    } else {
                        clearInterval(cooldownTimer);
                        cooldownTimer = null;
                        isCoolingDown = false;
                        
                        if (allWords.length > 0) {
                            displayCurrentWord();
                        } else {
                            fetchWords(); 
                        }
                    }
                }, 1000);

                return;
            }

            const currentWord = allWords[currentWordIndex];
            if (!currentWord) return;

            goodButton.disabled = true;
            badButton.disabled = true;
            notWordButton.disabled = true;
            
            const wordId = currentWord._id;
            const transitionDuration = 400; 
            
            if (voteType === 'good' || voteType === 'bad') {
                wordDisplay.classList.add(voteType === 'good' ? 'word-transition-good' : 'word-transition-bad');
            }

            try {
                const response = await fetch(`/api/words/${wordId}/vote`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ voteType, userId })
                });

                const result = await response.json();

                if (response.status === 403) {
                    voteStreak = 0; 
                    
                    if (voteType === 'good' || voteType === 'bad') {
                        setTimeout(() => {
                            nextWord();
                            fetchWords(false); 
                        }, transitionDuration); 
                    } else {
                         nextWord();
                         fetchWords(false);
                    }
                } else if (!response.ok) {
                    throw new Error(result.message || "Failed to register vote.");
                } else {
                    const previousVoteCount = voteCount; 
                    voteCount++;
                    localStorage.setItem('voteCount', voteCount);
                    updateAwardBadge();
                    
                    let awardAchieved = false;
                    let awardName = '';
                    let emoji = '';

                    if (previousVoteCount < 5 && voteCount >= 5) {
                        awardName = 'Bronze Star';
                        emoji = 'ðŸ¥‰';
                        awardAchieved = true;
                    } else if (previousVoteCount < 25 && voteCount >= 25) {
                        awardName = 'Silver Star';
                        emoji = 'ðŸ¥ˆ';
                        awardAchieved = true;
                    } else if (previousVoteCount < 50 && voteCount >= 50) {
                        awardName = 'Gold Star';
                        emoji = 'ðŸŒŸ';
                        awardAchieved = true;
                    }

                    if (awardAchieved) {
                        showAwardMessageAndContinue(awardName, emoji);
                    } else {
                        if (voteType === 'good' || voteType === 'bad') {
                            setTimeout(() => {
                                nextWord(); 
                                fetchWords(false); 
                            }, transitionDuration);
                        } else {
                            nextWord();
                            fetchWords(false);
                        }
                    }
                }
            } catch (error) {
                console.error('Error submitting vote:', error);
                showMessage("Vote failed. Try again.", true);
                wordDisplay.classList.remove('word-transition-good', 'word-transition-bad'); 
                goodButton.disabled = false;
                badButton.disabled = false;
                notWordButton.disabled = false;
                voteStreak = 0; 
            }
        }

        function getRankedWords(limit) {
            // Include all words fetched, not just 'availableWords'
            const allWordsFetched = JSON.parse(JSON.stringify(allWords)); // Deep copy to modify scores
            
            // Sticking to allWords, which is the "available" list filtered by (notWordVotes < 3)

            const rankedWords = allWordsFetched.map(w => ({
                text: w.text,
                good: w.goodVotes || 0,
                bad: w.badVotes || 0,
                score: (w.goodVotes || 0) - (w.badVotes || 0)
            }));

            const topGood = [...rankedWords]
                // .filter(w => w.score > -3) // This filter is now redundant as allWords already filters not-words
                .sort((a, b) => {
                    if (b.score !== a.score) return b.score - a.score;
                    return (b.good + b.bad) - (a.good + a.bad);
                })
                .slice(0, limit);

            const topBad = [...rankedWords]
                // .filter(w => w.score < 3) // This filter is now redundant as allWords already filters not-words
                .sort((a, b) => {
                    if (a.score !== b.score) return a.score - b.score;
                    return (b.good + b.bad) - (a.good + a.bad);
                })
                .slice(0, limit);
                
            return { topGood, topBad };
        }


        function updateStatsAndRankings() {
            if (allWords.length === 0) return;

            const totalGood = allWords.reduce((sum, w) => sum + (w.goodVotes || 0), 0);
            const totalBad = allWords.reduce((sum, w) => sum + (w.badVotes || 0), 0);
            goodTotal.textContent = `GOOD: ${totalGood}`;
            badTotal.textContent = `BAD: ${totalBad}`;
            // The word count is updated in fetchWords based on the raw response length.
            

            // Display Top 5 in the main card section
            const { topGood, topBad } = getRankedWords(5);
            renderRankings(goodRankingsDiv, topGood, 'good');
            renderRankings(badRankingsDiv, topBad, 'bad');
        }

        function renderRankings(container, list, type, isFullList = false) {
            container.innerHTML = '';
            if (list.length === 0) {
                container.innerHTML = `<p class="text-gray-500">${type === 'good' ? 'No clear winners yet.' : 'No clear losers yet.'}</p>`;
                return;
            }

            list.forEach((word, index) => {
                const item = document.createElement('div');
                item.className = `flex justify-between items-center py-1 ${isFullList ? 'full-ranking-item text-sm' : 'rank-item'}`;
                
                const scoreIndicator = type === 'good' 
                    ? `<span class="text-xs text-white bg-green-500 px-2 rounded-full font-bold">${word.score}</span>`
                    : `<span class="text-xs text-white bg-red-500 px-2 rounded-full font-bold">${Math.abs(word.score)}</span>`;
                
                item.innerHTML = `
                    <div class="flex items-center space-x-2">
                        <span class="font-bold ${isFullList ? 'text-base w-4' : 'text-lg w-5'} text-center text-gray-500">${index + 1}.</span>
                        <span class="font-medium text-gray-800">${word.text.toUpperCase()}</span>
                    </div>
                    <div class="flex items-center space-x-3">
                        ${scoreIndicator}
                        <span class="text-sm text-gray-600">(${word.good} / ${word.bad})</span>
                    </div>
                `;
                container.appendChild(item);
            });
        }
        
        // --- Full Rankings Modal Functions ---
        
        function showFullRankingsModal() {
            // Recalculate rankings based on the currently loaded words (allWords)
            const { topGood, topBad } = getRankedWords(100);
            
            // Render into the modal's div elements
            renderRankings(fullGoodRankingsDiv, topGood, 'good', true);
            renderRankings(fullBadRankingsDiv, topBad, 'bad', true);
            
            // Display the modal
            fullRankingsModalContainer.classList.remove('hidden');
            fullRankingsModalContainer.classList.add('flex');
        }

        function hideFullRankingsModal() {
            fullRankingsModalContainer.classList.remove('flex');
            fullRankingsModalContainer.classList.add('hidden');
        }
        // -------------------------------------


        function showModal() {
            submissionModal.classList.remove('hidden');
            submissionModal.classList.add('flex');
            newWordInput.value = '';
            modalMessage.textContent = '';
        }

        function hideModal() {
            submissionModal.classList.remove('flex');
            submissionModal.classList.add('hidden');
        }

        async function submitCustomWord() {
            const text = newWordInput.value.trim();
            if (!text) {
                modalMessage.textContent = "Please enter a word.";
                return;
            }

            submitWordButton.disabled = true;
            modalMessage.textContent = "Submitting...";

            try {
                const response = await fetch(API_BASE_URL, { 
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ text })
                });

                const result = await response.json();
                
                if (response.status === 201) {
                    modalMessage.textContent = "Success! Word added to the pool.";
                    setTimeout(() => {
                        hideModal();
                        fetchWords();
                    }, 1000);
                } else {
                    modalMessage.textContent = result.message || "Failed to submit word due to an unknown error.";
                }

            } catch (error) {
                console.error('Error submitting custom word:', error);
                modalMessage.textContent = "A network error occurred.";
            } finally {
                submitWordButton.disabled = false;
            }
        }

        window.onload = init;

    </script>
</body>
</html>
please remove comments

Here is the complete index.html file with all comments removed.

HTML
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GOOD WORD / BAD WORD</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&display=swap" rel="stylesheet">
    <style>
        body { 
            font-family: 'Inter', sans-serif; 
            background: linear-gradient(135deg, #f0fff0 0%, #e0f7fa 100%);
        }
        .card { 
            backdrop-filter: blur(10px); 
            background-color: rgba(255, 255, 255, 0.95);
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.15);
            border: 1px solid rgba(0, 0, 0, 0.05);
            transition: transform 0.2s ease-out, box-shadow 0.2s ease-out;
        }
        #gameCard:hover {
            transform: translateY(-4px);
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.2);
        }
        .good-button { background: linear-gradient(145deg, #10b981, #059669); }
        .bad-button { background: linear-gradient(145deg, #ef4444, #dc2626); }
        .not-word-button { background: linear-gradient(145deg, #64748b, #475569); }
        button { transition: transform 0.1s ease, box-shadow 0.1s ease; }
        button:active { transform: scale(0.98); box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2); }
        
        .version-indicator { 
            position: fixed; 
            bottom: 5px; 
            left: 50%; 
            transform: translateX(-50%); 
            font-size: 0.75rem; 
            color: #9ca3af; 
            z-index: 50; 
        }
        #cakeMessage {
            font-size: 1.125rem;
            font-weight: 700;
            color: #4b5563;
            margin-top: -1.5rem;
            margin-bottom: 1rem;
            opacity: 0;
            transition: opacity 0.3s ease-in-out;
        }
        .opacity-100 { opacity: 1; }

        @media (max-width: 640px) {
            .rank-item { font-size: 0.8rem; }
            .vote-counts { font-size: 0.875rem; }
        }

        .word-transition-good {
            animation: slide-out-left-good 0.4s ease-out forwards;
        }
        .word-transition-bad {
            animation: slide-out-right-bad 0.4s ease-out forwards;
        }

        @keyframes slide-out-left-good {
            0% { 
                transform: translateX(0); 
                opacity: 1; 
                color: #111827;
            }
            100% { 
                transform: translateX(-150%); 
                opacity: 0; 
                color: #10b981;
            }
        }
        
        @keyframes slide-out-right-bad {
            0% { 
                transform: translateX(0); 
                opacity: 1; 
                color: #111827;
            }
            100% { 
                transform: translateX(150%); 
                opacity: 0; 
                color: #ef4444;
            }
        }

        #wordDisplay {
            font-size: 6rem;
            white-space: nowrap; 
            overflow: hidden;
            max-width: 100%; 
            padding: 0 1rem; 
            box-sizing: border-box;
        }
        #fullRankingsModal {
            max-width: 800px;
            max-height: 90vh;
            overflow-y: auto;
        }
        .full-ranking-item {
            border-bottom: 1px solid #e5e7eb;
        }
    </style>
</head>
<body class="flex flex-col items-center justify-center min-h-screen p-4">

    <header class="text-center mb-8 w-full max-w-lg">
        <div id="logoArea" class="h-32 w-full flex items-center justify-center mb-4 relative">
            <img 
                src="logo.png" 
                alt="Good Word / Bad Word Logo with Rainbow and Devil" 
                class="h-full w-auto max-w-full"
            >
            <div id="awardBadge" class="absolute top-2 right-2 p-2 cursor-help text-3xl">
                </div>
        </div>
        <div class="mt-4 flex justify-around p-3 rounded-t-xl bg-white shadow-md vote-counts">
            <div id="goodTotal" class="text-xl font-bold text-green-600">GOOD: 0</div>
            <div id="badTotal" class="text-xl font-bold text-red-600">BAD: 0</div>
        </div>
        <div class="flex justify-center p-2 rounded-b-xl bg-gray-50 shadow-md">
            <div id="wordCount" class="text-sm font-semibold text-gray-500">
                Words in Database: 0
            </div>
        </div>
    </header>

    <main id="gameCard" class="card p-8 w-full max-w-sm flex flex-col items-center rounded-2xl">
        <div id="wordDisplay" class="font-extrabold text-gray-900 mb-8 text-center min-h-[72px]">
            Loading...
        </div>
        <div id="cakeMessage" class="text-center">
            </div>
        
        <div class="flex space-x-4 w-full mb-3">
            <button id="goodButton" class="good-button flex-1 py-4 text-white text-lg font-bold rounded-xl shadow-lg hover:shadow-xl focus:outline-none focus:ring-4 focus:ring-green-500/50" disabled>
                Good Word
            </button>
            <button id="badButton" class="bad-button flex-1 py-4 text-white text-lg font-bold rounded-xl shadow-lg hover:shadow-xl focus:outline-none focus:ring-4 focus:ring-red-500/50" disabled>
                Bad Word
            </button>
        </div>
        <button id="notWordButton" class="not-word-button w-full py-3 text-white text-lg font-bold rounded-xl shadow-lg hover:shadow-xl focus:outline-none focus:ring-4 focus:ring-slate-500/50" disabled>
            Not a word!
        </button>
        <button id="customWordButton" class="mt-4 text-sm text-gray-600 hover:text-gray-900 transition duration-150">
            Submit Custom Word
        </button>
    </main>

    <section class="mt-8 w-full max-w-4xl grid grid-cols-1 md:grid-cols-2 gap-8">
        <div class="card p-6 rounded-xl">
            <h2 class="text-xl font-bold text-green-700 mb-4 border-b pb-2">Top Good Words (Good > Bad)</h2>
            <div id="goodRankings" class="space-y-2">
                <p class="text-gray-500">No data yet.</p>
            </div>
        </div>
        <div class="card p-6 rounded-xl">
            <h2 class="text-xl font-bold text-red-700 mb-4 border-b pb-2">Top Bad Words (Bad > Good)</h2>
            <div id="badRankings" class="space-y-2">
                <p class="text-gray-500">No data yet.</p>
            </div>
        </div>
    </section>
    
    <div class="mt-6 w-full max-w-4xl text-center">
        <button id="showTop100Button" class="px-6 py-2 bg-blue-600 text-white font-bold rounded-lg shadow-md hover:bg-blue-700 transition duration-150">
            Show Top 100 Rankings
        </button>
    </div>

    <div id="submissionModal" class="fixed inset-0 bg-gray-900 bg-opacity-75 hidden items-center justify-center p-4 z-50">
        <div class="bg-white p-6 rounded-xl w-full max-w-md shadow-2xl">
            <h2 class="text-2xl font-bold mb-4">Submit a New Word</h2>
            <input type="text" id="newWordInput" placeholder="Enter your word here..." class="w-full p-3 border border-gray-300 rounded-lg mb-4 focus:ring-2 focus:ring-indigo-500">
            <div id="modalMessage" class="text-sm text-red-500 mb-4"></div>
            <div class="flex justify-end space-x-3">
                <button id="cancelSubmitButton" class="px-4 py-2 bg-gray-200 text-gray-700 font-medium rounded-lg hover:bg-gray-300 transition">
                    Cancel
                </button>
                <button id="submitWordButton" class="px-4 py-2 bg-indigo-600 text-white font-medium rounded-lg hover:bg-indigo-700 transition">
                    Submit Word
                </button>
            </div>
        </div>
    </div>
    
    <div id="fullRankingsModalContainer" class="fixed inset-0 bg-gray-900 bg-opacity-75 hidden items-center justify-center p-4 z-50">
        <div id="fullRankingsModal" class="bg-white p-6 rounded-xl w-full shadow-2xl">
            <div class="flex justify-between items-center mb-4 border-b pb-2">
                <h2 class="text-2xl font-bold">Top 100 Word Rankings</h2>
                <button id="closeFullRankingsModal" class="text-gray-500 hover:text-gray-800 text-2xl font-bold leading-none">
                    &times;
                </button>
            </div>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                <div>
                    <h3 class="text-lg font-semibold text-green-700 mb-2">Top Good Words</h3>
                    <div id="fullGoodRankings" class="space-y-1">
                        </div>
                </div>
                <div>
                    <h3 class="text-lg font-semibold text-red-700 mb-2">Top Bad Words</h3>
                    <div id="fullBadRankings" class="space-y-1">
                        </div>
                </div>
            </div>
        </div>
    </div>


    <div class="version-indicator">
        v3.3.3.0 | Made by Gilxs in 12,025
    </div>

    <script>
        const API_BASE_URL = '/api/words';
        const APP_VERSION = '3.3.2'; 

        let allWords = [];
        let currentWordIndex = 0;
        let userId = localStorage.getItem('userId');
        let voteCount = 0; 
        
        let voteStreak = 0;
        const MASH_LIMIT = 10;
        const COOLDOWN_SECONDS = 10;
        const STREAK_WINDOW_MS = 1500; 
        let cooldownTimer = null;
        let isCoolingDown = false;
        let lastVoteTime = 0; 

        const wordDisplay = document.getElementById('wordDisplay');
        const cakeMessage = document.getElementById('cakeMessage');
        const goodButton = document.getElementById('goodButton');
        const badButton = document.getElementById('badButton');
        const notWordButton = document.getElementById('notWordButton');
        const goodTotal = document.getElementById('goodTotal');
        const badTotal = document.getElementById('badTotal');
        const wordCount = document.getElementById('wordCount');
        const goodRankingsDiv = document.getElementById('goodRankings');
        const badRankingsDiv = document.getElementById('badRankings');
        const submissionModal = document.getElementById('submissionModal');
        const newWordInput = document.getElementById('newWordInput');
        const modalMessage = document.getElementById('modalMessage');
        const submitWordButton = document.getElementById('submitWordButton');
        const cancelSubmitButton = document.getElementById('cancelSubmitButton');
        const customWordButton = document.getElementById('customWordButton');
        const versionIndicator = document.querySelector('.version-indicator');
        const awardBadge = document.getElementById('awardBadge');
        const showTop100Button = document.getElementById('showTop100Button');
        const fullRankingsModalContainer = document.getElementById('fullRankingsModalContainer');
        const closeFullRankingsModal = document.getElementById('closeFullRankingsModal');
        const fullGoodRankingsDiv = document.getElementById('fullGoodRankings');
        const fullBadRankingsDiv = document.getElementById('fullBadRankings');

        function init() {
            if (!userId) {
                userId = crypto.randomUUID();
                localStorage.setItem('userId', userId);
            }
            
            const storedVoteCount = localStorage.getItem('voteCount');
            if (storedVoteCount) {
                voteCount = parseInt(storedVoteCount, 10);
            }

            versionIndicator.textContent = `v${APP_VERSION} | Made by Gilxs in 12,025`;
            
            goodButton.addEventListener('click', () => submitVote('good'));
            badButton.addEventListener('click', () => submitVote('bad'));
            notWordButton.addEventListener('click', () => submitVote('notWord'));
            customWordButton.addEventListener('click', () => showModal());
            cancelSubmitButton.addEventListener('click', () => hideModal());
            submitWordButton.addEventListener('click', submitCustomWord);
            
            showTop100Button.addEventListener('click', showFullRankingsModal);
            closeFullRankingsModal.addEventListener('click', hideFullRankingsModal);
            fullRankingsModalContainer.addEventListener('click', (e) => {
                if (e.target === fullRankingsModalContainer) {
                    hideFullRankingsModal();
                }
            });

            fetchWords();
            updateAwardBadge();
            
            window.addEventListener('resize', () => {
                if (allWords.length > 0) {
                    displayCurrentWord(); 
                }
            });
        }

        function updateAwardBadge() {
            let star = '';
            let title = '';
            
            if (voteCount >= 50) {
                star = 'ðŸŒŸ';
                title = `Gold Star Award! (${voteCount} Votes)`;
            } else if (voteCount >= 25) {
                star = 'ðŸ¥ˆ';
                title = `Silver Star Award! (${voteCount} Votes)`;
            } else if (voteCount >= 5) {
                star = 'ðŸ¥‰';
                title = `Bronze Star Award! (${voteCount} Votes)`;
            } else {
                star = 'âœ¨';
                title = `Votes: ${voteCount}. Next Award: Bronze (5 Votes)`;
            }

            awardBadge.textContent = star;
            awardBadge.title = title;
        }
        
        function showAwardMessageAndContinue(awardName, emoji) {
            wordDisplay.textContent = `${emoji} ${awardName} Unlocked! ${emoji}`;
            wordDisplay.className = 'text-4xl font-extrabold text-green-700 mb-8 text-center min-h-[72px] animate-pulse';
            wordDisplay.style.fontSize = '2.25rem'; 

            cakeMessage.classList.remove('opacity-100');
            cakeMessage.classList.add('opacity-0');
            cakeMessage.textContent = ''; 

            goodButton.disabled = true;
            badButton.disabled = true;
            notWordButton.disabled = true;

            setTimeout(() => {
                wordDisplay.classList.remove('animate-pulse');
                nextWord(); 
                fetchWords(false);
            }, 2500);
        }

        function showMessage(text, isError = false) {
            wordDisplay.textContent = text;
            wordDisplay.className = `text-4xl font-bold text-center mb-8 min-h-[72px] ${isError ? 'text-red-500' : 'text-gray-500'}`;
            wordDisplay.style.fontSize = '1.5rem'; 

            goodButton.disabled = true;
            badButton.disabled = true;
            notWordButton.disabled = true;

            cakeMessage.classList.remove('opacity-100');
            cakeMessage.classList.add('opacity-0');
            cakeMessage.textContent = '';
        }
        
        function showCooldownMessage(remainingSeconds) {
            wordDisplay.textContent = `Button mashing will not be tolerated. Wait ${remainingSeconds}s...`;
            wordDisplay.className = 'text-4xl font-bold text-red-600 mb-8 text-center min-h-[72px]';
            wordDisplay.style.fontSize = '1.5rem'; 
            
            goodButton.disabled = true;
            badButton.disabled = true;
            notWordButton.disabled = true;

            cakeMessage.classList.remove('opacity-100');
            cakeMessage.classList.add('opacity-0');
            cakeMessage.textContent = '';
        }

        function displayCurrentWord() {
            if (allWords.length === 0) {
                showMessage("No words available! Try submitting one.", false);
                return;
            }
            
            const currentWord = allWords[currentWordIndex];
            const wordText = currentWord.text.toUpperCase();
            
            wordDisplay.classList.remove('word-transition-good', 'word-transition-bad');
            
            wordDisplay.textContent = wordText;
            wordDisplay.className = 'font-extrabold text-gray-900 mb-8 text-center min-h-[72px]';
            
            const cardWidth = document.getElementById('gameCard').clientWidth - 64; 
            const maxFontSize = 96; 
            
            wordDisplay.style.fontSize = `${maxFontSize}px`;
            wordDisplay.style.whiteSpace = 'nowrap';

            let currentWidth = wordDisplay.scrollWidth;
            let finalFontSize = maxFontSize;

            if (currentWidth > cardWidth) {
                const scaleFactor = cardWidth / currentWidth;
                finalFontSize = Math.floor(maxFontSize * scaleFactor);
                if (finalFontSize < 24) finalFontSize = 24; 
            }
            
            wordDisplay.style.fontSize = `${finalFontSize}px`;
            wordDisplay.style.whiteSpace = 'normal'; 
            
            if (wordText === 'CAKE') {
                cakeMessage.textContent = 'The cake is a lie!';
                cakeMessage.classList.remove('opacity-0');
                cakeMessage.classList.add('opacity-100');
            } else {
                cakeMessage.classList.remove('opacity-100');
                cakeMessage.classList.add('opacity-0');
                cakeMessage.textContent = ''; 
            }
            
            goodButton.disabled = false;
            badButton.disabled = false;
            notWordButton.disabled = false;
        }

        function nextWord() {
            if (allWords.length === 0) return;
            
            const wordsWithVoteCounts = allWords
                .map((w, index) => ({
                    index,
                    totalVotes: (w.goodVotes || 0) + (w.badVotes || 0) + (w.notWordVotes || 0)
                }))
                .filter(w => w.index !== currentWordIndex);

            if (wordsWithVoteCounts.length === 0) {
                displayCurrentWord();
                return;
            }

            const minVotes = wordsWithVoteCounts.reduce((min, w) => Math.min(min, w.totalVotes), Infinity);
            
            const lowestVotedWords = wordsWithVoteCounts.filter(w => w.totalVotes === minVotes);
            
            const selectedWord = lowestVotedWords[Math.floor(Math.random() * lowestVotedWords.length)];
            currentWordIndex = selectedWord.index;
            
            displayCurrentWord();
        }

        async function fetchWords(updateDisplay = true) {
            try {
                if(updateDisplay) {
                    showMessage("Loading words...", false);
                }
                const response = await fetch(API_BASE_URL);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                let fetchedWords = await response.json();
                
                const availableWords = fetchedWords.filter(w => (w.notWordVotes || 0) < 3);
                allWords = availableWords;
                
                wordCount.textContent = `Words in Database: ${fetchedWords.length}`;
                
                if (allWords.length > 0) {
                    updateStatsAndRankings();
                    
                    if (updateDisplay) {
                        const wordsWithVoteCounts = allWords.map((w, index) => ({
                            index,
                            totalVotes: (w.goodVotes || 0) + (w.badVotes || 0) + (w.notWordVotes || 0)
                        }));

                        const minVotes = wordsWithVoteCounts.reduce((min, w) => Math.min(min, w.totalVotes), Infinity);
                        
                        const lowestVotedWords = wordsWithVoteCounts.filter(w => w.totalVotes === minVotes);
                        
                        const selectedWord = lowestVotedWords[Math.floor(Math.random() * lowestVotedWords.length)];
                        currentWordIndex = selectedWord.index;
                        
                        displayCurrentWord();
                    } 
                } else {
                    showMessage("No words available! Try submitting one.", false);
                }

            } catch (error) {
                console.error('Error fetching words:', error);
                if(updateDisplay) {
                    showMessage("Connection Error. Check your API URL.", true);
                }
            }
        }

        async function submitVote(voteType) {
            if (isCoolingDown) {
                const remaining = Math.ceil((cooldownEndTime - Date.now()) / 1000);
                showCooldownMessage(remaining > 0 ? remaining : 0);
                return;
            }

            const now = Date.now();
            if (lastVoteTime > 0 && (now - lastVoteTime) > STREAK_WINDOW_MS) {
                voteStreak = 1; 
            } else {
                voteStreak++; 
            }
            lastVoteTime = now; 

            if (voteStreak > MASH_LIMIT) {
                isCoolingDown = true;
                voteStreak = 0; 
                
                let remaining = COOLDOWN_SECONDS;
                const cooldownEndTime = Date.now() + COOLDOWN_SECONDS * 1000;

                showCooldownMessage(remaining);

                cooldownTimer = setInterval(() => {
                    remaining--;
                    if (remaining > 0) {
                        showCooldownMessage(remaining);
                    } else {
                        clearInterval(cooldownTimer);
                        cooldownTimer = null;
                        isCoolingDown = false;
                        
                        if (allWords.length > 0) {
                            displayCurrentWord();
                        } else {
                            fetchWords(); 
                        }
                    }
                }, 1000);

                return;
            }

            const currentWord = allWords[currentWordIndex];
            if (!currentWord) return;

            goodButton.disabled = true;
            badButton.disabled = true;
            notWordButton.disabled = true;
            
            const wordId = currentWord._id;
            const transitionDuration = 400; 
            
            if (voteType === 'good' || voteType === 'bad') {
                wordDisplay.classList.add(voteType === 'good' ? 'word-transition-good' : 'word-transition-bad');
            }

            try {
                const response = await fetch(`/api/words/${wordId}/vote`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ voteType, userId })
                });

                const result = await response.json();

                if (response.status === 403) {
                    voteStreak = 0; 
                    
                    if (voteType === 'good' || voteType === 'bad') {
                        setTimeout(() => {
                            nextWord();
                            fetchWords(false); 
                        }, transitionDuration); 
                    } else {
                         nextWord();
                         fetchWords(false);
                    }
                } else if (!response.ok) {
                    throw new Error(result.message || "Failed to register vote.");
                } else {
                    const previousVoteCount = voteCount; 
                    voteCount++;
                    localStorage.setItem('voteCount', voteCount);
                    updateAwardBadge();
                    
                    let awardAchieved = false;
                    let awardName = '';
                    let emoji = '';

                    if (previousVoteCount < 5 && voteCount >= 5) {
                        awardName = 'Bronze Star';
                        emoji = 'ðŸ¥‰';
                        awardAchieved = true;
                    } else if (previousVoteCount < 25 && voteCount >= 25) {
                        awardName = 'Silver Star';
                        emoji = 'ðŸ¥ˆ';
                        awardAchieved = true;
                    } else if (previousVoteCount < 50 && voteCount >= 50) {
                        awardName = 'Gold Star';
                        emoji = 'ðŸŒŸ';
                        awardAchieved = true;
                    }

                    if (awardAchieved) {
                        showAwardMessageAndContinue(awardName, emoji);
                    } else {
                        if (voteType === 'good' || voteType === 'bad') {
                            setTimeout(() => {
                                nextWord(); 
                                fetchWords(false); 
                            }, transitionDuration);
                        } else {
                            nextWord();
                            fetchWords(false);
                        }
                    }
                }
            } catch (error) {
                console.error('Error submitting vote:', error);
                showMessage("Vote failed. Try again.", true);
                wordDisplay.classList.remove('word-transition-good', 'word-transition-bad'); 
                goodButton.disabled = false;
                badButton.disabled = false;
                notWordButton.disabled = false;
                voteStreak = 0; 
            }
        }

        function getRankedWords(limit) {
            const allWordsFetched = JSON.parse(JSON.stringify(allWords));
            
            const rankedWords = allWordsFetched.map(w => ({
                text: w.text,
                good: w.goodVotes || 0,
                bad: w.badVotes || 0,
                score: (w.goodVotes || 0) - (w.badVotes || 0)
            }));

            const topGood = [...rankedWords]
                .sort((a, b) => {
                    if (b.score !== a.score) return b.score - a.score;
                    return (b.good + b.bad) - (a.good + a.bad);
                })
                .slice(0, limit);

            const topBad = [...rankedWords]
                .sort((a, b) => {
                    if (a.score !== b.score) return a.score - b.score;
                    return (b.good + b.bad) - (a.good + a.bad);
                })
                .slice(0, limit);
                
            return { topGood, topBad };
        }


        function updateStatsAndRankings() {
            if (allWords.length === 0) return;

            const totalGood = allWords.reduce((sum, w) => sum + (w.goodVotes || 0), 0);
            const totalBad = allWords.reduce((sum, w) => sum + (w.badVotes || 0), 0);
            goodTotal.textContent = `GOOD: ${totalGood}`;
            badTotal.textContent = `BAD: ${totalBad}`;
            
            const { topGood, topBad } = getRankedWords(5);
            renderRankings(goodRankingsDiv, topGood, 'good');
            renderRankings(badRankingsDiv, topBad, 'bad');
        }

        function renderRankings(container, list, type, isFullList = false) {
            container.innerHTML = '';
            if (list.length === 0) {
                container.innerHTML = `<p class="text-gray-500">${type === 'good' ? 'No clear winners yet.' : 'No clear losers yet.'}</p>`;
                return;
            }

            list.forEach((word, index) => {
                const item = document.createElement('div');
                item.className =



Gemini can make mistakes, including about people, so double-check it. Your privacy and GeminiOpens in a new window

