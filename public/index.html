<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Good Word/Bad Word Classifier (Render API)</title>
    <!-- Load Tailwind CSS via CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    
    <style>
        /* Base Variables and Fonts */
        :root {
            --good-color: #4CAF50; /* Green */
            --bad-color: #F44336; /* Red */
            --neutral-color: #FFC107; /* Orange/Yellow */
            --bg-color: #f0f2f5;
            --card-bg: #fff;
            --border-radius: 16px;
        }

        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(to bottom right, #e0ffe0 0%, var(--bg-color) 50%, #ffe0e0 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            padding: 2rem 1rem;
        }

        .game-container {
            background-color: var(--card-bg);
            border-radius: var(--border-radius);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            padding: 2rem;
            max-width: 900px;
            width: 100%;
        }

        /* Word Card Styles */
        .word-card-wrapper {
            position: relative;
            perspective: 1000px;
        }
        .word-card {
            background-color: var(--card-bg);
            border-radius: var(--border-radius);
            padding: 2rem 1rem;
            min-height: 120px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            transition: all 0.5s ease-in-out;
            border: 4px solid;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.08);
            transform-style: preserve-3d;
        }
        
        /* Border color states */
        .neutral-border { border-color: var(--neutral-color); }
        .good-border { border-color: var(--good-color); }
        .bad-border { border-color: var(--bad-color); }

        .word-card.flip-out {
            transform: rotateX(90deg);
            opacity: 0;
        }
        .word-card.flip-in {
            transform: rotateX(0deg);
            opacity: 1;
        }

        .text-word {
            font-size: 3.5rem;
            font-weight: 900;
            line-height: 1;
            text-transform: uppercase;
        }

        /* Button Styles */
        .vote-btn {
            padding: 1rem 1.5rem;
            font-weight: bold;
            border-radius: 9999px;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.1);
            transition: transform 0.2s, box-shadow 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }
        .vote-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.2);
        }
        .vote-btn:active:not(:disabled) {
            transform: translateY(0);
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1);
        }

        .good-btn {
            background-color: var(--good-color);
            color: white;
            box-shadow: 0 4px 15px rgba(76, 175, 80, 0.4);
        }
        .bad-btn {
            background-color: var(--bad-color);
            color: white;
            box-shadow: 0 4px 15px rgba(244, 67, 54, 0.4);
        }

        /* List Styles */
        .top-words-section ul {
            list-style: none;
            padding: 0;
        }
        .top-words-section li {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem 0;
            border-bottom: 1px solid #eee;
        }
        .top-words-section li:last-child {
            border-bottom: none;
        }
        
        /* Utility for messages */
        .message-success { background-color: var(--good-color); color: white; }
        .message-error { background-color: var(--bad-color); color: white; }
        .message-info { background-color: #4b5563; color: white; } 

        /* Modal backdrop for visual appeal */
        .modal-backdrop {
            background-color: rgba(0, 0, 0, 0.75);
            backdrop-filter: blur(4px);
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen flex flex-col items-center justify-start p-4 sm:p-8">
    
    <!-- Main Game Container -->
    <div class="game-container w-full max-w-4xl">
        <header class="text-center mb-10">
            <h1 class="text-5xl font-extrabold tracking-tighter text-gray-800">
                <span style="color: var(--good-color);">GOOD WORD</span> / <span style="color: var(--bad-color);">BAD WORD</span>
            </h1>
            <p class="text-xl text-gray-500 mt-2">Classify words submitted by the community (Render API client).</p>
        </header>

        <!-- Main Interaction Area -->
        <div class="word-card-area relative flex flex-col items-center justify-center p-6 mb-10">

            <!-- Dynamic Message Display Area -->
            <div id="messageDisplay" class="absolute -top-10 left-1/2 transform -translate-x-1/2 p-2 px-4 rounded-xl shadow-lg font-semibold text-sm hidden z-10">
            </div>

            <div class="word-card-wrapper relative min-h-[150px] w-full max-w-lg">
                <div class="word-card neutral-border flip-in" id="wordBox">
                    <p class="text-xs font-semibold tracking-widest text-gray-400 mb-2">CURRENT WORD</p>
                    <span id="wordDisplay" class="text-word text-gray-900">LOADING...</span>
                </div>
            </div>
            
            <!-- Vote Buttons -->
            <div class="vote-buttons flex justify-center gap-6 mt-10 w-full max-w-lg">
                <button id="goodWordBtn" class="vote-btn good-btn flex-1 transition-all duration-300 disabled:opacity-50 disabled:cursor-not-allowed" disabled>
                    <i class="fas fa-thumbs-up icon"></i>
                    Good Word
                </button>
                <button id="badWordBtn" class="vote-btn bad-btn flex-1 transition-all duration-300 disabled:opacity-50 disabled:cursor-not-allowed" disabled>
                    <i class="fas fa-thumbs-down icon"></i>
                    Bad Word
                </button>
            </div>
        </div>
        
        <!-- Management and Leaderboard Section -->
        <section class="mt-12 pt-6 border-t border-gray-200 top-words-section">
            <div class="flex justify-between items-center mb-6">
                <h2 class="text-2xl font-bold text-gray-700">Community Ratings</h2>
                <button id="showAddWordModalBtn" class="px-4 py-2 bg-gray-700 text-white rounded-lg hover:bg-gray-800 transition duration-150 text-sm shadow-md" disabled>
                    <i class="fas fa-plus mr-2"></i>Suggest a Word
                </button>
            </div>
            
            <!-- Top Words Leaderboard -->
            <div class="top-words-lists flex flex-wrap justify-center gap-6">
                
                <!-- Mostly Good List -->
                <div class="mostly-good bg-white p-6 rounded-xl shadow-md flex-1 min-w-[300px] lg:min-w-0 border-t-4" style="border-top-color: var(--good-color);">
                    <h3 class="text-lg font-bold mb-4 text-gray-700" style="color: var(--good-color);">Mostly Good</h3>
                    <ul id="mostlyGoodList" class="space-y-2">
                        <li class="text-center italic text-sm text-gray-500">Loading leaderboard...</li>
                    </ul>
                </div>

                <!-- Mostly Bad List -->
                <div class="mostly-bad bg-white p-6 rounded-xl shadow-md flex-1 min-w-[300px] lg:min-w-0 border-t-4" style="border-top-color: var(--bad-color);">
                    <h3 class="text-lg font-bold mb-4 text-gray-700" style="color: var(--bad-color);">Mostly Bad</h3>
                    <ul id="mostlyBadList" class="space-y-2">
                        <li class="text-center italic text-sm text-gray-500">Loading leaderboard...</li>
                    </ul>
                </div>
            </div>
        </section>

        <!-- Footer for App Version -->
        <footer class="mt-8 text-center text-xs text-gray-400">
            App Version: v8.7.3 (Render API Client - Enhanced Debugging)
        </footer>
    </div>
    
    <!-- Add Word Modal -->
    <div id="addWordModal" class="fixed inset-0 hidden z-50 flex items-center justify-center modal-backdrop transition-opacity duration-300">
        <div class="bg-white p-8 rounded-xl shadow-2xl w-full max-w-md transform scale-100 transition-transform duration-300">
            <h3 class="text-xl font-bold mb-4 text-gray-800">Suggest a New Word</h3>
            <input type="text" id="newWordInput" placeholder="Enter word (e.g., 'Sunshine')" 
                   class="w-full p-3 border-2 border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-gray-700 mb-4 text-lg">
            
            <p id="wordSubmissionMessage" class="text-sm hidden mb-4 font-medium"></p>
            
            <div class="flex justify-end gap-3">
                <button id="cancelAddWordBtn" class="px-4 py-2 border border-gray-300 rounded-lg text-gray-700 hover:bg-gray-100 transition duration-150">
                    Cancel
                </button>
                <button id="submitNewWordBtn" class="px-4 py-2 bg-gray-700 text-white rounded-lg hover:bg-gray-800 transition duration-150 shadow-md disabled:opacity-50" disabled>
                    Submit Word
                </button>
            </div>
        </div>
    </div>


    <script>
        // CRITICAL CONFIGURATION:
        const API_BASE_URL = 'https://good-word.onrender.com';
        
        // Hypothetical API Endpoints (You must ensure your server implements these)
        const GET_UNCLASSIFIED_WORD_ENDPOINT = '/api/get-word'; 
        const GET_RANDOM_WORD_ENDPOINT = '/api/get-random-word'; 
        
        // --- GLOBAL STATE ---
        let currentWordId = null;
        let currentWordText = null;

        // --- DOM Elements ---
        const wordDisplay = document.getElementById('wordDisplay');
        const goodWordBtn = document.getElementById('goodWordBtn');
        const badWordBtn = document.getElementById('badWordBtn');
        const wordBox = document.getElementById('wordBox');
        const messageDisplay = document.getElementById('messageDisplay');
        const mostlyGoodList = document.getElementById('mostlyGoodList');
        const mostlyBadList = document.getElementById('mostlyBadList');
        
        // Modal elements
        const addWordModal = document.getElementById('addWordModal');
        const showAddWordModalBtn = document.getElementById('showAddWordModalBtn');
        const cancelAddWordBtn = document.getElementById('cancelAddWordBtn');
        const submitNewWordBtn = document.getElementById('submitNewWordBtn');
        const newWordInput = document.getElementById('newWordInput');
        const wordSubmissionMessage = document.getElementById('wordSubmissionMessage');

        // --- UTILITY FUNCTIONS ---

        /**
         * Displays a temporary status message to the user.
         */
        function showMessage(message, type) {
            messageDisplay.textContent = message;
            
            const baseClasses = 'absolute -top-10 left-1/2 transform -translate-x-1/2 p-2 px-4 rounded-xl shadow-lg font-semibold text-sm z-10';
            messageDisplay.className = baseClasses;
            messageDisplay.classList.remove('hidden');

            let bgColorClass;

            switch (type) {
                case 'success':
                case 'good': 
                    bgColorClass = 'message-success';
                    break;
                case 'error':
                case 'bad': 
                    bgColorClass = 'message-error';
                    break;
                case 'info':
                default:
                    bgColorClass = 'message-info';
                    break;
            }

            messageDisplay.classList.add(bgColorClass);

            // Hide after 3 seconds
            setTimeout(() => {
                messageDisplay.classList.add('hidden');
            }, 3000);
        }

        /**
         * Sets the word box border color and applies a flip animation.
         */
        function setWordBoxState(type, animate = true) {
            wordBox.classList.remove('neutral-border', 'good-border', 'bad-border');
            wordBox.classList.add(`${type}-border`);

            if (animate) {
                 // Trigger flip out animation
                wordBox.classList.add('flip-out');
                
                // Wait for animation to complete before setting new word and flipping back in
                setTimeout(() => {
                    wordBox.classList.remove('flip-out');
                    wordBox.classList.add('flip-in');
                }, 250); // Half of the transition time
            } else {
                 wordBox.classList.remove('flip-out');
                 wordBox.classList.add('flip-in');
            }
        }

        /**
         * Enables or disables the voting and suggestion buttons.
         */
        function toggleButtons(enable) {
            goodWordBtn.disabled = !enable;
            badWordBtn.disabled = !enable;
            showAddWordModalBtn.disabled = !enable;
        }

        // --- API INTERACTION ---

        /**
         * Core fetch function to try both unclassified and random endpoints.
         */
        async function fetchWordFromApi(endpoint) {
             const fetchUrl = `${API_BASE_URL}${endpoint}`;
             const response = await fetch(fetchUrl);

            if (!response.ok) {
                const errorText = await response.text();
                console.error(`Backend HTTP Error (${response.status}) from ${endpoint}:`, errorText.substring(0, 500));
                
                if (response.status === 404 && endpoint === GET_RANDOM_WORD_ENDPOINT) {
                    return { word: null, _id: null, message: "No API fallback endpoint available." };
                }
                
                if (response.status >= 500) {
                    throw new Error(`SERVER ERROR (${response.status}). Check Render/MongoDB logs.`);
                }
                
                const errorSnippet = errorText.substring(0, 50).replace(/(\r\n|\n|\r)/gm, " ");
                throw new Error(`API Error: Status ${response.status} - Response: ${errorSnippet}...`);
            }
            
            let data;
            try {
                // *** CRITICAL CHANGE: Robust JSON parsing check ***
                data = await response.json();
            } catch (jsonError) {
                // If JSON parsing fails, read the raw text and log a detailed error.
                const responseText = await response.text();
                console.error("--- JSON PARSING FAILED ---");
                console.error(`Attempted to parse JSON from ${endpoint} but failed. Raw Response:`, responseText.substring(0, 500));
                console.error("This usually means the server returned an HTML error page or plain text instead of JSON.");
                console.error("--- END OF RESPONSE DEBUG ---");
                throw new Error("Invalid API response format. Check console for raw server output.");
            }

            return data;
        }

        /**
         * Fetches the next word to classify, falling back to a random word if the pool is empty.
         */
        async function fetchNextWord() {
            toggleButtons(false);
            wordDisplay.textContent = "LOADING...";
            setWordBoxState('neutral', false);
            
            if (!API_BASE_URL) {
                 wordDisplay.textContent = "API URL MISSING";
                 showMessage("CRITICAL: API_BASE_URL is missing!", 'error');
                 return;
            }
            
            let wordData = { word: null, _id: null };

            try {
                // 1. Try to get the next UNCLASSIFIED word
                console.log(`1. Trying to fetch UNCLASSIFIED word from ${GET_UNCLASSIFIED_WORD_ENDPOINT}...`);
                wordData = await fetchWordFromApi(GET_UNCLASSIFIED_WORD_ENDPOINT);
                
                // If the response is empty (no word/id), try the fallback
                if (!wordData.word || !wordData._id) {
                     console.log("-> Unclassified word pool is empty or API confirmed no words left. Trying to fetch a RANDOM word...");

                     // 2. Try to get a RANDOM word
                     wordData = await fetchWordFromApi(GET_RANDOM_WORD_ENDPOINT);
                }
                
                // 3. Process the final wordData
                if (wordData.word && wordData._id) {
                    currentWordId = wordData._id; 
                    currentWordText = wordData.word;
                    wordDisplay.textContent = currentWordText.toUpperCase();
                    setWordBoxState('neutral', true);
                    toggleButtons(true);
                    console.log("Word loaded:", currentWordText, "ID:", currentWordId);
                } else {
                    currentWordId = null;
                    currentWordText = null;
                    wordDisplay.textContent = "NO WORDS AVAILABLE";
                    toggleButtons(false);
                    showAddWordModalBtn.disabled = false;
                    showMessage("Database words exhausted or API issue. Please suggest one.", 'info');
                }
                
            } catch (error) {
                console.error("Fetch Word Error:", error.message);
                wordDisplay.textContent = "API ERROR";
                // Show the specific error message from the try-catch block
                showMessage(`Connection Error: ${error.message}`, 'error'); 
                
                showAddWordModalBtn.disabled = false;
            }
        }

        /**
         * Sends the classification vote to the API (Global vote, no userId sent).
         */
        async function sendVote(sentiment) {
            if (!currentWordId) {
                showMessage("Cannot vote: No word loaded.", 'error');
                return;
            }

            toggleButtons(false);
            setWordBoxState(sentiment, true); 

            try {
                const response = await fetch(`${API_BASE_URL}/api/vote`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        wordId: currentWordId, 
                        sentiment: sentiment,
                    })
                });

                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    if (response.status >= 500) {
                         throw new Error(`SERVER ERROR (Status ${response.status}). Check Render/MongoDB logs.`);
                    }
                    throw new Error(errorData.message || `API Error (${response.status}) on vote.`);
                }
                
                showMessage(`Voted ${sentiment.toUpperCase()}!`, sentiment);
                
                fetchNextWord();
                fetchTopWords(); 
                
            } catch (error) {
                console.error("Vote Error:", error.message);
                showMessage(`Error submitting vote: ${error.message}`, 'error');
                
                toggleButtons(true);
                setWordBoxState('neutral', false);
            }
        }

        /**
         * Fetches the top words list from the API.
         */
        async function fetchTopWords() {
            if (!API_BASE_URL) { return; }

            mostlyGoodList.innerHTML = '<li class="text-center italic text-sm text-gray-500">Loading leaderboard...</li>';
            mostlyBadList.innerHTML = '<li class="text-center italic text-sm text-gray-500">Loading leaderboard...</li>';

            try {
                const response = await fetch(`${API_BASE_URL}/api/top-words`);

                if (!response.ok) {
                    const errorText = await response.text();
                    console.error("Backend Error Detail (Top Words):", errorText);

                    if (response.status >= 500) {
                         throw new Error(`SERVER ERROR (Status ${response.status}). Check Render/MongoDB logs.`);
                    }
                    throw new Error(`API Error: Status ${response.status}`);
                }
                const data = await response.json();
                
                // Clear and re-populate lists
                mostlyGoodList.innerHTML = '';
                mostlyBadList.innerHTML = '';
                const classifiedWords = data.words || [];

                if (classifiedWords.length === 0) {
                    const noVotesMessage = '<li class="text-center italic text-sm text-gray-500 p-2">No votes recorded yet.</li>';
                    mostlyGoodList.innerHTML = noVotesMessage;
                    mostlyBadList.innerHTML = noVotesMessage;
                    return;
                }

                const goodList = classifiedWords
                    .filter(item => item.goodPercent && item.goodPercent > 50)
                    .sort((a, b) => b.goodPercent - a.goodPercent)
                    .slice(0, 5);
                
                const badList = classifiedWords
                    .filter(item => item.badPercent && item.badPercent >= 50)
                    .sort((a, b) => b.badPercent - a.badPercent)
                    .slice(0, 5);

                const noGoodMsg = '<li class="text-center italic text-sm text-gray-500 p-2">None classified as mostly Good yet.</li>';
                const noBadMsg = '<li class="text-center italic text-sm text-gray-500 p-2">None classified as mostly Bad yet.</li>';


                const renderList = (list, element, color, defaultMessage) => {
                     if (list.length > 0) {
                        list.forEach(item => {
                            const li = document.createElement('li');
                            const percentage = color === 'good' ? item.goodPercent : item.badPercent;
                            li.className = 'flex justify-between items-center text-gray-700 border-b border-gray-100 last:border-b-0';
                            li.innerHTML = `
                                <span class="font-semibold text-sm">${item.word.toUpperCase()}</span>
                                <span class="font-bold text-lg" style="color: var(--${color}-color);">${Math.round(percentage)}%</span>
                            `;
                            element.appendChild(li);
                        });
                    } else {
                        element.innerHTML = defaultMessage;
                    }
                }

                renderList(goodList, mostlyGoodList, 'good', noGoodMsg);
                renderList(badList, mostlyBadList, 'bad', noBadMsg);


            } catch (error) {
                console.error("Fetch Top Words Error:", error.message);
                const errorMessage = error.message.includes('SyntaxError') ? 'API returned invalid JSON.' : error.message;
                const errorMsgLi = `<li class="text-center italic text-sm text-red-500">Error loading list: ${errorMessage}.</li>`;
                mostlyGoodList.innerHTML = errorMsgLi;
                mostlyBadList.innerHTML = errorMsgLi;
            }
        }


        /**
         * Handles submission of a new word via the modal.
         */
        async function handleSubmitNewWord() {
            const word = newWordInput.value.trim().toLowerCase();
            if (word.length < 2 || !/^[a-z]+$/.test(word)) {
                wordSubmissionMessage.textContent = "Word must be 2+ letters and contain only letters.";
                wordSubmissionMessage.classList.remove('hidden');
                wordSubmissionMessage.classList.add('text-red-600');
                return;
            }

            submitNewWordBtn.disabled = true;
            
            try {
                const response = await fetch(`${API_BASE_URL}/api/add-word`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ word: word })
                });

                if (!response.ok) {
                     const errorData = await response.json().catch(() => ({}));
                     if (response.status >= 500) {
                         throw new Error(`SERVER ERROR (Status ${response.status}). Check Render/MongoDB logs.`);
                    }
                     throw new Error(errorData.message || `API Error (${response.status}) on add word.`);
                }
                
                wordSubmissionMessage.textContent = `Successfully added word: '${word}'! It is now available for classification.`;
                wordSubmissionMessage.classList.remove('hidden');
                wordSubmissionMessage.classList.add('text-green-600');
                
                newWordInput.value = '';
                
                // Close modal after a short delay
                setTimeout(() => {
                    addWordModal.classList.add('hidden');
                    // Fetch next word to show the newly added one if possible
                    fetchNextWord();
                    fetchTopWords();
                }, 1500);

            } catch (error) {
                console.error("Error submitting new word:", error);
                wordSubmissionMessage.textContent = error.message.includes('exists') 
                    ? `The word '${word}' already exists!` 
                    : `Failed to submit word: ${error.message}`;
                wordSubmissionMessage.classList.remove('hidden');
                wordSubmissionMessage.classList.add('text-red-600');
            } finally {
                submitNewWordBtn.disabled = false;
            }
        }

        // --- SETUP LISTENERS ---
        function setupListeners() {
            // Vote Listeners
            goodWordBtn.addEventListener('click', () => sendVote('good'));
            badWordBtn.addEventListener('click', () => sendVote('bad'));
            
            // Modal Listeners
            showAddWordModalBtn.addEventListener('click', () => {
                addWordModal.classList.remove('hidden');
                newWordInput.focus();
                wordSubmissionMessage.classList.add('hidden');
                wordSubmissionMessage.classList.remove('text-red-600', 'text-green-600');
                submitNewWordBtn.disabled = true; 
            });
            cancelAddWordBtn.addEventListener('click', () => addWordModal.classList.add('hidden'));
            submitNewWordBtn.addEventListener('click', handleSubmitNewWord);
            
            // Input Listener for Submit Button state
            newWordInput.addEventListener('input', () => {
                const word = newWordInput.value.trim();
                submitNewWordBtn.disabled = !(word.length >= 2 && /^[a-z]+$/i.test(word));
                wordSubmissionMessage.classList.add('hidden');
            });
            
            // Close modal on outside click
            addWordModal.addEventListener('click', (e) => {
                if (e.target === addWordModal) {
                    addWordModal.classList.add('hidden');
                }
            });

            // Refresh the top words list every 10 seconds 
            setInterval(fetchTopWords, 10000); 
        }


        // --- App Start ---
        window.onload = () => {
            console.log("Application starting - Render API Mode (v8.7.3 Enhanced Debugging)...");
            setupListeners();
            
            fetchTopWords();
            fetchNextWord();
        };

    </script>
</body>
</html>
