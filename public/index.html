<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Good Word App</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        :root {
            font-family: 'Inter', sans-serif;
        }
        .text-shadow {
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.2);
        }
        .modal {
            transition: opacity 0.3s ease-in-out;
        }
        .modal.hidden {
            opacity: 0;
            pointer-events: none;
        }
    </style>
</head>
<body class="bg-gray-50 min-h-screen p-4 flex flex-col items-center">

    <!-- Header and Tabs -->
    <header class="w-full max-w-4xl mb-6">
        <h1 class="text-4xl font-extrabold text-blue-600 text-center mb-6 text-shadow">
            Good Word: Collaborative Dictionary
        </h1>
        <div class="flex justify-center space-x-2 p-1 bg-white rounded-xl shadow-lg border border-gray-100">
            <button id="tab-vote" onclick="switchTab('vote')" class="tab-button active">
                <i data-lucide="thumbs-up" class="w-5 h-5 mr-2"></i> Vote on Words
            </button>
            <button id="tab-submit" onclick="switchTab('submit')" class="tab-button">
                <i data-lucide="plus-circle" class="w-5 h-5 mr-2"></i> Submit New Word
            </button>
            <button id="tab-rankings" onclick="switchTab('rankings')" class="tab-button">
                <i data-lucide="trophy" class="w-5 h-5 mr-2"></i> Global Rankings
            </button>
        </div>
    </header>

    <!-- Main Content Area -->
    <main class="w-full max-w-2xl bg-white p-6 rounded-xl shadow-2xl border border-gray-200">

        <!-- User/Auth Info -->
        <div id="auth-info" class="text-xs text-gray-500 mb-4 text-center">
            Loading user...
        </div>

        <!-- Tab Content Containers -->
        <div id="content-vote" class="tab-content active">
            <!-- Word Voting UI -->
            <div id="word-card" class="bg-blue-50 p-6 rounded-lg shadow-inner flex flex-col items-center justify-center min-h-[250px] transition-all duration-300">
                <div id="word-content" class="text-center">
                    <p id="current-word-text" class="text-6xl font-black text-blue-800 animate-pulse">Loading...</p>
                    <p id="current-word-definition" class="text-xl text-gray-700 mt-3 italic">Please wait while we fetch a word.</p>
                </div>
                <div id="vote-controls" class="mt-8 flex space-x-6">
                    <button onclick="handleVote('bad')" class="vote-button bg-red-500 hover:bg-red-600">
                        <i data-lucide="thumbs-down" class="w-6 h-6"></i> Bad
                    </button>
                    <button onclick="handleVote('good')" class="vote-button bg-green-500 hover:bg-green-600">
                        <i data-lucide="thumbs-up" class="w-6 h-6"></i> Good
                    </button>
                </div>
                <div id="vote-message" class="mt-4 text-sm font-semibold text-gray-600 transition-opacity duration-300 opacity-0"></div>
            </div>
        </div>

        <div id="content-submit" class="tab-content hidden">
            <!-- Word Submission UI -->
            <h2 class="text-2xl font-semibold text-gray-800 mb-4">Suggest a New Word for the World!</h2>
            <form id="submit-form" class="space-y-4">
                <div>
                    <label for="new-word" class="block text-sm font-medium text-gray-700">Word (e.g., "Mellifluous")</label>
                    <input type="text" id="new-word" required maxlength="50" class="mt-1 block w-full border-gray-300 rounded-md shadow-sm p-3 focus:ring-blue-500 focus:border-blue-500">
                </div>
                <div>
                    <label for="new-definition" class="block text-sm font-medium text-gray-700">Definition (must be accurate and clear)</label>
                    <textarea id="new-definition" required maxlength="250" rows="3" class="mt-1 block w-full border-gray-300 rounded-md shadow-sm p-3 focus:ring-blue-500 focus:border-blue-500"></textarea>
                </div>
                <button type="submit" class="w-full py-3 px-4 border border-transparent rounded-lg shadow-md text-white bg-blue-600 hover:bg-blue-700 font-medium transition duration-150 ease-in-out flex items-center justify-center">
                    <span id="submit-text">Submit Word</span>
                    <i id="submit-spinner" data-lucide="loader-2" class="w-5 h-5 ml-2 animate-spin hidden"></i>
                </button>
            </form>
            <div id="submit-status" class="mt-4 p-3 rounded-lg text-center font-medium hidden"></div>
        </div>

        <div id="content-rankings" class="tab-content hidden">
            <!-- Global Rankings UI -->
            <h2 class="text-2xl font-semibold text-gray-800 mb-4">Global Word Rankings</h2>
            <p class="text-sm text-gray-500 mb-4">The best words, as voted by everyone.</p>

            <div id="rankings-list" class="space-y-3">
                <div class="text-center p-4 text-gray-500">
                    <i data-lucide="loader-2" class="w-6 h-6 mx-auto animate-spin"></i>
                    <p class="mt-2">Loading global rankings...</p>
                </div>
            </div>
            <div id="rankings-status" class="mt-4 p-3 rounded-lg text-center font-medium hidden"></div>
        </div>

    </main>

    <!-- Generic Modal for Messages (replaces alert/confirm) -->
    <div id="message-modal" class="modal fixed inset-0 bg-gray-900 bg-opacity-50 z-50 flex items-center justify-center hidden">
        <div class="bg-white p-6 rounded-lg shadow-2xl w-full max-w-sm transform scale-100 transition-transform duration-300">
            <h3 id="modal-title" class="text-xl font-bold mb-3 text-gray-800"></h3>
            <p id="modal-body" class="text-gray-600 mb-5"></p>
            <div class="flex justify-end space-x-3">
                <button id="modal-confirm" class="py-2 px-4 rounded-lg text-white bg-blue-600 hover:bg-blue-700 font-medium hidden">Confirm</button>
                <button id="modal-close" class="py-2 px-4 rounded-lg text-gray-700 bg-gray-200 hover:bg-gray-300 font-medium">Close</button>
            </div>
        </div>
    </div>

    <!-- Firebase SDKs -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, onSnapshot, collection, query, limit, updateDoc, arrayUnion } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Global variables provided by the environment
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}');
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const auth = getAuth(app);
        
        // Setting Firebase log level for debugging
        setLogLevel('debug');

        window.db = db;
        window.auth = auth;

        let userId = null;
        let isAuthReady = false;

        // 1. Authentication Setup
        onAuthStateChanged(auth, async (user) => {
            if (user) {
                userId = user.uid;
                document.getElementById('auth-info').textContent = `User ID: ${userId} | Status: Signed In`;
                
                // Get the user's private list of voted words to prevent re-voting
                const userDocRef = doc(db, "artifacts", appId, "users", userId, "config", "votes");
                const userDoc = await getDoc(userDocRef);
                window.votedWords = userDoc.exists() ? new Set(userDoc.data().wordIds || []) : new Set();
                
            } else {
                // Sign in anonymously if no custom token is available
                if (initialAuthToken) {
                    try {
                        await signInWithCustomToken(auth, initialAuthToken);
                    } catch (error) {
                        console.error("Error signing in with custom token:", error);
                        await signInAnonymously(auth);
                    }
                } else {
                    await signInAnonymously(auth);
                }
            }
            isAuthReady = true;
            // The main app logic starts here (fetching the first word)
            fetchNextWord();
        });

        // 2. Data Storage Functions
        /**
         * Updates the user's private list of words they have voted on.
         * @param {string} wordId - The ID of the word just voted on.
         */
        window.recordUserVote = async (wordId) => {
            if (!userId) return;

            const userDocRef = doc(db, "artifacts", appId, "users", userId, "config", "votes");

            try {
                // Add the wordId to the set of voted words
                window.votedWords.add(wordId);

                // Use Firestore arrayUnion to atomically update the list
                await setDoc(userDocRef, { 
                    wordIds: arrayUnion(wordId) 
                }, { merge: true });
                
            } catch (error) {
                console.error("Error recording user vote in Firestore:", error);
            }
        };

        // 3. API Communication (Corrected URLs and Backoff)

        // API Configuration (FINAL CORRECTED ENDPOINTS)
        const API_BASE = 'https://good-word.onrender.com';
        // CONFIRMED ENDPOINTS
        const API_GET_RANDOM_WORD = `${API_BASE}/api/get-word`;
        const API_GET_WORDS = `${API_BASE}/api/top-words`;
        // HIGHLY LIKELY ENDPOINTS based on the established pattern
        const API_SUBMIT_WORD = `${API_BASE}/api/add-word`; 
        const API_VOTE = `${API_BASE}/api/vote-word`; 

        /**
         * Generic fetch wrapper with exponential backoff retry.
         * @param {string} url - The URL to fetch.
         * @param {object} options - Fetch options (method, headers, body, etc.).
         * @param {number} retries - Number of retries left.
         */
        async function fetchWithRetry(url, options = {}, retries = 3) {
            let delay = 1000; // 1 second base delay
            for (let i = 0; i < retries; i++) {
                try {
                    const response = await fetch(url, options);
                    
                    if (response.ok) {
                        // Check content-type to avoid JSON parsing errors on non-JSON responses
                        const contentType = response.headers.get("content-type");
                        if (contentType && contentType.includes("application/json")) {
                            return await response.json();
                        } else {
                            // If response is OK but not JSON (e.g., a simple 'success' text), return the response object
                            return response;
                        }
                    }

                    // Handle bad status codes (4xx, 5xx)
                    throw new Error(`HTTP Error: ${response.status} ${response.statusText}`);

                } catch (error) {
                    console.warn(`Fetch attempt ${i + 1} failed for ${url}: ${error.message}. Retrying in ${delay / 1000}s...`);
                    if (i === retries - 1) {
                        throw error; // Throw final error
                    }
                    await new Promise(resolve => setTimeout(resolve, delay));
                    delay *= 2; // Exponential backoff
                }
            }
        }

        /**
         * Fetches the next word to be voted on.
         */
        window.fetchNextWord = async () => {
            const wordText = document.getElementById('current-word-text');
            const defText = document.getElementById('current-word-definition');
            const card = document.getElementById('word-card');
            const controls = document.getElementById('vote-controls');

            wordText.textContent = "Loading...";
            wordText.classList.add('animate-pulse');
            defText.textContent = "Please wait while we fetch a word.";
            controls.classList.add('hidden');
            card.dataset.wordId = '';

            try {
                const data = await fetchWithRetry(API_GET_RANDOM_WORD);

                // Assuming the API returns a structure like { id: '...', word: '...', definition: '...' }
                if (data && data.word) {
                    const wordId = data.id;

                    // If the user has already voted on this word, skip it.
                    if (window.votedWords.has(wordId)) {
                        defText.textContent = "You've already voted on this word! Fetching another...";
                        setTimeout(window.fetchNextWord, 1000); // Wait 1 second and try again
                        return;
                    }

                    wordText.textContent = data.word;
                    defText.textContent = data.definition;
                    card.dataset.wordId = wordId;
                    controls.classList.remove('hidden');
                    wordText.classList.remove('animate-pulse');

                } else {
                    defText.textContent = "No more words to vote on right now! Try submitting one.";
                    wordText.textContent = "Finished!";
                    wordText.classList.remove('animate-pulse');
                }
            } catch (error) {
                // If the error is a generic fetch error, we try to parse the body as text for better debugging
                let serverResponse = error.message;
                if (error.response && error.response.text) {
                     serverResponse = await error.response.text();
                } else if (error.response) {
                    serverResponse = `HTTP ${error.response.status}`;
                }

                console.error("Error fetching word:", error);
                defText.textContent = `Error fetching word: ${error.message} (Server response in console)`;
                wordText.textContent = "Error";
                wordText.classList.remove('animate-pulse');
                showModal('API Error', `Could not load a word. Check the console for details on the server's unexpected response.`, 'error');
            }
        };


        /**
         * Handles the voting action (good or bad).
         * @param {string} voteType - 'good' or 'bad'.
         */
        window.handleVote = async (voteType) => {
            const card = document.getElementById('word-card');
            const wordId = card.dataset.wordId;
            const messageEl = document.getElementById('vote-message');

            if (!wordId) {
                showModal('Voting Error', 'Cannot vote: no word ID found.', 'error');
                return;
            }

            // Prevent double voting and show feedback
            if (window.votedWords.has(wordId)) {
                showMessage('You already voted on this word!', 'text-red-600');
                return;
            }
            
            // Temporary UI feedback
            document.getElementById('vote-controls').classList.add('hidden');
            showMessage('Submitting vote...', 'text-blue-600');

            try {
                // 1. API Call to register the vote
                const data = await fetchWithRetry(API_VOTE, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        id: wordId,
                        vote: voteType,
                        userId: userId, // Pass Firebase user ID to API for tracking
                    }),
                });

                if (data.success) {
                    showMessage('Vote recorded! Fetching next word...', 'text-green-600');
                    // 2. Record vote in Firestore
                    await recordUserVote(wordId);
                    
                    // 3. Fetch the next word
                    setTimeout(window.fetchNextWord, 1000);
                } else {
                    throw new Error(data.message || "Unknown API error.");
                }

            } catch (error) {
                console.error("Error voting:", error);
                showMessage('Vote failed. Try again.', 'text-red-600');
                document.getElementById('vote-controls').classList.remove('hidden'); // Restore controls on failure
            }
        };

        /**
         * Fetches and displays the global word rankings.
         */
        window.fetchGlobalWords = async () => {
            const listEl = document.getElementById('rankings-list');
            const statusEl = document.getElementById('rankings-status');

            listEl.innerHTML = `
                <div class="text-center p-4 text-gray-500">
                    <i data-lucide="loader-2" class="w-6 h-6 mx-auto animate-spin"></i>
                    <p class="mt-2">Loading global rankings...</p>
                </div>
            `;
            statusEl.classList.add('hidden');

            try {
                const words = await fetchWithRetry(API_GET_WORDS);
                
                if (words && Array.isArray(words) && words.length > 0) {
                    listEl.innerHTML = words.map((word, index) => `
                        <div class="flex justify-between items-center p-4 bg-gray-50 rounded-lg shadow-sm border border-gray-200">
                            <div class="flex items-center">
                                <span class="text-3xl font-bold text-blue-500 mr-4 w-8 text-right">${index + 1}.</span>
                                <div>
                                    <p class="text-xl font-semibold text-gray-800">${word.word}</p>
                                    <p class="text-sm text-gray-600 italic">${word.definition}</p>
                                </div>
                            </div>
                            <span class="text-2xl font-black text-green-700">${word.score || 0}</span>
                        </div>
                    `).join('');
                } else {
                    listEl.innerHTML = '<p class="text-center p-4 text-gray-500">No words have been ranked yet. Be the first to submit one!</p>';
                }

            } catch (error) {
                console.error("Error fetching global word list:", error);
                const errorMessage = `Could not load rankings. The server returned an unexpected response. Check the console for details.`;
                listEl.innerHTML = `<p class="text-center p-4 text-red-500 font-semibold">${errorMessage}</p>`;
                showModal('API Error', errorMessage, 'error');
            }
        };

        // 4. Submission Handler
        document.getElementById('submit-form').addEventListener('submit', async (e) => {
            e.preventDefault();
            const wordInput = document.getElementById('new-word');
            const defInput = document.getElementById('new-definition');
            const word = wordInput.value.trim();
            const definition = defInput.value.trim();
            
            const submitText = document.getElementById('submit-text');
            const submitSpinner = document.getElementById('submit-spinner');
            const statusEl = document.getElementById('submit-status');

            submitText.textContent = 'Submitting...';
            submitSpinner.classList.remove('hidden');
            statusEl.classList.add('hidden');

            try {
                const data = await fetchWithRetry(API_SUBMIT_WORD, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ word, definition, submitterId: userId }),
                });

                if (data.success) {
                    statusEl.textContent = 'Success! Your word has been added for voting.';
                    statusEl.classList.remove('hidden', 'bg-red-100', 'text-red-700');
                    statusEl.classList.add('bg-green-100', 'text-green-700');
                    wordInput.value = '';
                    defInput.value = '';
                } else {
                    throw new Error(data.message || "Unknown submission error.");
                }

            } catch (error) {
                console.error("Error submitting word:", error);
                statusEl.textContent = `Submission failed: ${error.message}`;
                statusEl.classList.remove('hidden', 'bg-green-100', 'text-green-700');
                statusEl.classList.add('bg-red-100', 'text-red-700');
            } finally {
                submitText.textContent = 'Submit Word';
                submitSpinner.classList.add('hidden');
            }
        });


        // 5. General Utility Functions

        /**
         * Shows a temporary message above the vote buttons.
         * @param {string} text - The message to display.
         * @param {string} className - Tailwind class for styling (e.g., 'text-red-600').
         */
        function showMessage(text, className) {
            const messageEl = document.getElementById('vote-message');
            messageEl.textContent = text;
            messageEl.className = `mt-4 text-sm font-semibold transition-opacity duration-300 ${className}`;
            messageEl.classList.remove('opacity-0');
            setTimeout(() => {
                messageEl.classList.add('opacity-0');
            }, 3000);
        }
        
        /**
         * Switches the visible tab content.
         * @param {string} tabName - The name of the tab to switch to ('vote', 'submit', 'rankings').
         */
        window.switchTab = (tabName) => {
            // Update buttons
            document.querySelectorAll('.tab-button').forEach(btn => {
                btn.classList.remove('active', 'bg-blue-600', 'text-white', 'shadow-md');
                btn.classList.add('text-gray-600', 'hover:bg-blue-50');
            });

            const currentBtn = document.getElementById(`tab-${tabName}`);
            currentBtn.classList.add('active', 'bg-blue-600', 'text-white', 'shadow-md');
            currentBtn.classList.remove('text-gray-600', 'hover:bg-blue-50');

            // Update content
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.add('hidden');
            });
            document.getElementById(`content-${tabName}`).classList.remove('hidden');
            
            // Execute specific tab actions
            if (tabName === 'vote' && isAuthReady) {
                fetchNextWord();
            } else if (tabName === 'rankings') {
                fetchGlobalWords();
            }
        };

        // Initialize Lucide icons
        window.onload = () => {
            lucide.createIcons();
            // Apply initial tab styling
            document.getElementById('tab-vote').classList.add('active', 'bg-blue-600', 'text-white', 'shadow-md');
            document.getElementById('tab-vote').classList.remove('text-gray-600', 'hover:bg-blue-50');
        };

        // Global Modal Implementation
        const modalEl = document.getElementById('message-modal');
        const modalTitle = document.getElementById('modal-title');
        const modalBody = document.getElementById('modal-body');
        const modalClose = document.getElementById('modal-close');

        function showModal(title, message, type = 'info') {
            modalTitle.textContent = title;
            modalBody.textContent = message;
            
            // Apply basic styling based on type (optional)
            if (type === 'error') {
                modalTitle.classList.add('text-red-600');
            } else {
                modalTitle.classList.remove('text-red-600');
            }

            modalEl.classList.remove('hidden');
        }

        modalClose.onclick = () => {
            modalEl.classList.add('hidden');
        };
        
        // Tab button base style
        document.head.insertAdjacentHTML('beforeend', `
            <style>
                .tab-button {
                    flex-grow: 1;
                    padding: 0.75rem 1rem;
                    border-radius: 0.5rem;
                    font-weight: 600;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    transition: all 0.2s ease;
                }
                .vote-button {
                    padding: 1rem 2rem;
                    border-radius: 0.75rem;
                    font-weight: 700;
                    color: white;
                    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
                    transition: transform 0.1s;
                }
                .vote-button:active {
                    transform: scale(0.98);
                }
            </style>
        `);

    </script>
</body>
</html>
