<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GOOD WORD / BAD WORD</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom Font */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');
        
        /* Basic styling for the body */
        body {
            font-family: 'Inter', sans-serif;
        }
        
        /* Custom scrollbar for message box */
        #messageBox::-webkit-scrollbar {
            width: 6px;
        }

        #messageBox::-webkit-scrollbar-thumb {
            background: #d1d5db;
            border-radius: 3px;
        }

        /* Keyframes for a subtle card entrance animation */
        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(20px) scale(0.95);
            }
            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }

        .word-card {
            animation: slideIn 0.3s ease-out;
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen flex flex-col items-center justify-center p-4 font-inter">

    <!-- Main Game Container -->
    <div class="w-full max-w-lg mx-auto">
        <h1 class="text-4xl font-bold text-center text-gray-800 mb-6 tracking-tight">
            GOOD WORD / BAD WORD
        </h1>
        
        <!-- Stats and Rankings Card -->
        <div class="bg-white p-6 rounded-xl shadow-lg mb-8 transition-all duration-300">
            <div class="flex justify-between items-center mb-4">
                <span class="text-sm font-medium text-green-600 flex items-center">
                    Total Good Votes: <span id="totalGoodVotes" class="ml-1 font-bold text-lg">0</span>
                </span>
                <span class="text-sm font-medium text-red-600 flex items-center">
                    Total Bad Votes: <span id="totalBadVotes" class="ml-1 font-bold text-lg">0</span>
                </span>
            </div>

            <div id="rankingContainer" class="grid grid-cols-1 sm:grid-cols-2 gap-4 text-sm">
                <!-- Rankings will be injected here -->
            </div>
        </div>

        <!-- Word Card Area -->
        <div id="wordCardArea" class="word-card bg-white p-8 rounded-2xl shadow-2xl transition-all duration-300 transform min-h-[250px] flex flex-col justify-center items-center">
            <div id="wordDisplay" class="text-5xl font-extrabold text-gray-900 mb-8 text-center min-h-[60px] flex items-center justify-center">
                <!-- Word will be injected here -->
            </div>
            
            <div class="flex space-x-4 w-full justify-center">
                <button id="goodButton" class="flex-1 bg-green-500 hover:bg-green-600 text-white font-bold py-3 px-6 rounded-xl shadow-md transition-all duration-200 transform hover:scale-105 active:scale-95 text-lg disabled:opacity-50" disabled>
                    GOOD WORD
                </button>
                <button id="badButton" class="flex-1 bg-red-500 hover:bg-red-600 text-white font-bold py-3 px-6 rounded-xl shadow-md transition-all duration-200 transform hover:scale-105 active:scale-95 text-lg disabled:opacity-50" disabled>
                    BAD WORD
                </button>
            </div>
            <p id="voteMessage" class="mt-4 text-sm text-gray-600 italic h-4"></p>
        </div>
        
        <!-- Custom Word Submission Button -->
        <button id="submitWordBtn" class="w-full mt-6 bg-blue-500 hover:bg-blue-600 text-white font-semibold py-3 px-6 rounded-xl shadow-lg transition-all duration-200 transform hover:scale-[1.02] active:scale-[0.98]">
            Submit Custom Word
        </button>
    </div>

    <!-- Message/Error Modal -->
    <div id="messageModal" class="fixed inset-0 bg-black bg-opacity-50 hidden items-center justify-center z-50">
        <div class="bg-white p-6 rounded-xl shadow-2xl max-w-sm w-full">
            <h3 id="messageTitle" class="text-xl font-bold mb-3 text-gray-800"></h3>
            <p id="messageContent" class="text-gray-600 mb-6"></p>
            <button id="messageCloseBtn" class="w-full bg-blue-500 hover:bg-blue-600 text-white font-semibold py-2 rounded-lg transition-all duration-200">
                Close
            </button>
        </div>
    </div>

    <!-- Custom Word Submission Modal -->
    <div id="submissionModal" class="fixed inset-0 bg-black bg-opacity-50 hidden items-center justify-center z-50">
        <div class="bg-white p-6 rounded-xl shadow-2xl max-w-sm w-full">
            <h3 class="text-xl font-bold mb-4 text-gray-800">Suggest a Word</h3>
            <input type="text" id="newWordInput" class="w-full p-3 border border-gray-300 rounded-lg mb-4 focus:ring-blue-500 focus:border-blue-500" placeholder="Enter your word here">
            <div class="flex space-x-3">
                <button id="submitNewWordBtn" class="flex-1 bg-green-500 hover:bg-green-600 text-white font-semibold py-2 rounded-lg transition-all duration-200">
                    Submit
                </button>
                <button id="closeSubmissionModalBtn" class="flex-1 bg-gray-300 hover:bg-gray-400 text-gray-800 font-semibold py-2 rounded-lg transition-all duration-200">
                    Cancel
                </button>
            </div>
        </div>
    </div>
    
    <!-- Version Control Element (hidden at the bottom right) -->
    <div id="version-info" class="fixed bottom-0 right-0 p-1 text-xs text-gray-400 opacity-50 z-50 pointer-events-none"></div>

    <script>
        // --- Configuration ---
        // REPLACE THIS with your deployed Render API URL, e.g., 'https://your-game-api.onrender.com/api/words'
        const API_BASE_URL = 'http://localhost:3000/api/words';
        
        // UNIQUE ID: This prevents one user from voting multiple times on the same word.
        // It should persist for a single user session/browser.
        let userId = localStorage.getItem('goodBadWordUserId');
        if (!userId) {
            userId = crypto.randomUUID();
            localStorage.setItem('goodBadWordUserId', userId);
        }
        
        // TESTING VERSION: Used for testing deployments.
        const APP_VERSION = '1.0.3'; 

        // --- State Variables ---
        let currentWords = [];
        let currentIndex = -1;
        let isFetching = false;
        
        // --- DOM Elements ---
        const wordDisplay = document.getElementById('wordDisplay');
        const goodButton = document.getElementById('goodButton');
        const badButton = document.getElementById('badButton');
        const totalGoodVotesEl = document.getElementById('totalGoodVotes');
        const totalBadVotesEl = document.getElementById('totalBadVotes');
        const rankingContainer = document.getElementById('rankingContainer');
        const voteMessageEl = document.getElementById('voteMessage');

        // Modals and Submission
        const messageModal = document.getElementById('messageModal');
        const messageTitle = document.getElementById('messageTitle');
        const messageContent = document.getElementById('messageContent');
        const messageCloseBtn = document.getElementById('messageCloseBtn');
        const submissionModal = document.getElementById('submissionModal');
        const submitWordBtn = document.getElementById('submitWordBtn');
        const newWordInput = document.getElementById('newWordInput');
        const submitNewWordBtn = document.getElementById('submitNewWordBtn');
        const closeSubmissionModalBtn = document.getElementById('closeSubmissionModalBtn');
        
        // --- Utility Functions ---

        /**
         * Custom alert replacement using the modal for visibility in an iframe.
         */
        function showMessage(title, message) {
            messageTitle.textContent = title;
            messageContent.textContent = message;
            messageModal.classList.remove('hidden');
            messageModal.classList.add('flex');
        }

        function closeMessage() {
            messageModal.classList.add('hidden');
            messageModal.classList.remove('flex');
        }

        function showSubmissionModal() {
            submissionModal.classList.remove('hidden');
            submissionModal.classList.add('flex');
            newWordInput.value = '';
        }

        function closeSubmissionModal() {
            submissionModal.classList.add('hidden');
            submissionModal.classList.remove('flex');
        }

        /**
         * Fetch wrapper with exponential backoff for API robustness.
         */
        async function fetchWithRetry(url, options = {}, maxRetries = 3) {
            for (let i = 0; i < maxRetries; i++) {
                try {
                    const response = await fetch(url, options);
                    if (!response.ok) {
                        const errorData = await response.json().catch(() => ({ message: `HTTP error! Status: ${response.status}` }));
                        throw new Error(errorData.message || `HTTP error! Status: ${response.status}`);
                    }
                    return response;
                } catch (error) {
                    if (i === maxRetries - 1) {
                        throw error;
                    }
                    const delay = Math.pow(2, i) * 1000;
                    await new Promise(resolve => setTimeout(resolve, delay));
                }
            }
        }

        // --- Game Logic ---

        /**
         * Fetches words from the backend, updates UI state, and calculates rankings.
         */
        async function fetchWords() {
            if (isFetching) return;
            isFetching = true;
            try {
                const response = await fetchWithRetry(API_BASE_URL);
                const words = await response.json();
                
                // Filter for active words and ensure we have some to display
                currentWords = words.filter(word => word.isActive);
                
                if (currentWords.length === 0) {
                    wordDisplay.textContent = 'No active words found!';
                    disableVoting(true);
                    return;
                }

                updateStatsAndRankings(currentWords);
                nextWord(); // Move to the next word after fetching

            } catch (error) {
                console.error('Failed to fetch game state:', error);
                showMessage('Connection Error', `Could not connect to the backend API: ${error.message}. Please check your Render deployment.`);
            } finally {
                isFetching = false;
            }
        }

        /**
         * Cycles to the next word in the list and updates the display.
         */
        function nextWord() {
            if (currentWords.length === 0) {
                return;
            }
            
            currentIndex = (currentIndex + 1) % currentWords.length;
            const word = currentWords[currentIndex];
            wordDisplay.textContent = word.text.toUpperCase();
            
            // Re-enable voting buttons (they are disabled immediately after a vote)
            disableVoting(false);
            voteMessageEl.textContent = 'Vote!';
        }

        /**
         * Sends the vote to the backend API.
         * @param {string} voteType 'good' or 'bad'.
         */
        async function sendVote(voteType) {
            if (currentIndex === -1 || isFetching) return;

            const word = currentWords[currentIndex];
            const url = `${API_BASE_URL}/${word._id}/vote`;
            
            disableVoting(true);
            voteMessageEl.textContent = 'Recording vote...';

            try {
                const response = await fetchWithRetry(url, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ voteType, userId })
                });

                // Update the current word object locally with the response data (optional but good practice)
                const result = await response.json(); 
                
                // Success feedback
                const message = voteType === 'good' ? 'Nice! Vote recorded.' : 'Ouch! Vote recorded.';
                voteMessageEl.textContent = message;

                // After a short delay, move to the next word
                setTimeout(() => {
                    fetchWords(); // Refresh all data to get latest stats
                }, 800);

            } catch (error) {
                // Check for 403 Forbidden error (user already voted)
                if (error.message && error.message.includes('403')) {
                    showMessage('Already Voted', `You've already cast your vote on "${word.text.toUpperCase()}".`);
                } else {
                    showMessage('Vote Error', `Failed to register vote: ${error.message}`);
                }
                
                // In case of error, re-enable buttons and move on
                setTimeout(() => {
                    disableVoting(false);
                    nextWord();
                }, 2000); 
            }
        }
        
        /**
         * Disables or enables the main voting buttons.
         * @param {boolean} disabled
         */
        function disableVoting(disabled) {
            goodButton.disabled = disabled;
            badButton.disabled = disabled;
        }

        /**
         * Renders the total votes and the top-ranked words.
         * @param {Array} words The full list of words from the backend.
         */
        function updateStatsAndRankings(words) {
            let totalGood = 0;
            let totalBad = 0;
            
            words.forEach(word => {
                totalGood += word.goodVotes;
                totalBad += word.badVotes;
            });
            
            totalGoodVotesEl.textContent = totalGood.toLocaleString();
            totalBadVotesEl.textContent = totalBad.toLocaleString();

            // Calculate Rankings (Simple ranking based on margin/bias)
            const rankedWords = words.map(word => ({
                text: word.text,
                good: word.goodVotes,
                bad: word.badVotes,
                netScore: word.goodVotes - word.badVotes,
                total: word.goodVotes + word.badVotes
            })).filter(word => word.total > 0); // Only show ranked words with votes

            // Top Good Words (High positive net score)
            const topGood = rankedWords
                .filter(w => w.netScore > 0)
                .sort((a, b) => b.netScore - a.netScore)
                .slice(0, 5);

            // Top Bad Words (High negative net score)
            const topBad = rankedWords
                .filter(w => w.netScore < 0)
                .sort((a, b) => a.netScore - b.netScore)
                .slice(0, 5);


            rankingContainer.innerHTML = `
                <div>
                    <h4 class="font-bold text-green-700 mb-2 border-b border-green-200 pb-1">üèÜ Top Good Words</h4>
                    <ul class="space-y-1">
                        ${topGood.length > 0 ? topGood.map((w, i) => 
                            `<li class="flex justify-between items-center">${i + 1}. ${w.text} <span class="font-medium text-green-600">(${w.good})</span></li>`
                        ).join('') : '<li class="text-gray-500">No data yet.</li>'}
                    </ul>
                </div>
                <div>
                    <h4 class="font-bold text-red-700 mb-2 border-b border-red-200 pb-1">üíÄ Top Bad Words</h4>
                    <ul class="space-y-1">
                        ${topBad.length > 0 ? topBad.map((w, i) => 
                            `<li class="flex justify-between items-center">${i + 1}. ${w.text} <span class="font-medium text-red-600">(${w.bad})</span></li>`
                        ).join('') : '<li class="text-gray-500">No data yet.</li>'}
                    </ul>
                </div>
            `;
        }

        // --- Submission Logic ---

        /**
         * Sends a new word suggestion to the backend.
         */
        async function submitNewWord() {
            const wordText = newWordInput.value.trim();

            if (!wordText) {
                return showMessage('Missing Word', 'Please enter a word to submit.');
            }
            if (wordText.includes(' ') || wordText.length > 20) {
                 return showMessage('Invalid Word', 'Word must be single-word and less than 20 characters.');
            }
            
            closeSubmissionModal();
            showMessage('Submitting...', `Attempting to add "${wordText}"...`);

            try {
                await fetchWithRetry(API_BASE_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ text: wordText })
                });

                showMessage('Success!', `"${wordText}" has been submitted for approval and will appear soon.`);
                fetchWords(); // Refresh the list to potentially include the new word immediately

            } catch (error) {
                if (error.message && error.message.includes('409')) {
                     showMessage('Duplicate Word', `The word "${wordText}" is already in the system.`);
                } else {
                    showMessage('Submission Error', `Failed to submit word: ${error.message}`);
                }
            }
        }
        
        /**
         * Displays the current version number in the footer.
         */
        function displayVersion() {
            const versionEl = document.getElementById('version-info');
            if (versionEl) {
                versionEl.textContent = `v${APP_VERSION}`;
            }
        }


        // --- Event Listeners and Initialization ---

        function init() {
            // Setup buttons
            goodButton.addEventListener('click', () => sendVote('good'));
            badButton.addEventListener('click', () => sendVote('bad'));
            
            // Setup modals
            messageCloseBtn.addEventListener('click', closeMessage);
            submitWordBtn.addEventListener('click', showSubmissionModal);
            closeSubmissionModalBtn.addEventListener('click', closeSubmissionModal);
            submitNewWordBtn.addEventListener('click', submitNewWord);
            
            // Initial data load and periodic refresh
            fetchWords(); // <--- FIX: Added parenthesis and semicolon
            // Refresh game state every 10 seconds to keep stats and rankings current
            setInterval(fetchWords, 10000); 
            
            // Display testing version
            displayVersion();
        }

        window.onload = init;
    </script>
</body>
</html>
