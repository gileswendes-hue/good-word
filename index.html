<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Good/Bad Word Game v1.5.2</title>
    <!-- Load Tailwind CSS for modern styling and responsiveness -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    },
                    colors: {
                        'good-green': '#10b981', // Emerald 500
                        'bad-red': '#ef4444',     // Red 500
                        'neutral-gray': '#6b7280', // Gray 500
                    }
                }
            }
        }
    </script>
    <style>
        /* Base styles */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
        }

        /* Card specific styles */
        .word-card {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 150px;
            font-size: 2.5rem;
            font-weight: 700;
            cursor: pointer;
            transition: none; /* Crucial: Ensure no accidental transitions */
        }

        /* Border styles for vote history */
        .neutral-border { border-color: #6b7280; }
        .good-border { border-color: #10b981; }
        .bad-border { border-color: #ef4444; }

        /* Engagement Message Styles */
        #engagementMessageBox {
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
            pointer-events: none; /* Important: allows clicks through when hidden */
        }

        #engagementMessageBox.visible {
            opacity: 1;
        }

        /* Leaderboard list styling */
        .leaderboard-list li {
            padding: 4px 0;
            border-bottom: 1px solid #e5e7eb;
            font-size: 0.9rem;
            display: flex;
            justify-content: space-between;
        }
        .leaderboard-list li:last-child {
            border-bottom: none;
        }

        /* Version Display */
        #appVersionDisplay {
            position: absolute;
            bottom: 5px;
            right: 5px;
            font-size: 0.75rem;
            color: #9ca3af; /* Gray 400 */
        }
    </style>
</head>
<body class="selection:bg-good-green selection:text-white">

    <div id="appContainer" class="w-full max-w-xl bg-white p-6 md:p-8 rounded-xl shadow-2xl space-y-8 relative">
        
        <!-- App Header -->
        <header class="text-center space-y-2">
            <h1 class="text-3xl font-extrabold text-gray-800">Word Classifier</h1>
            <p class="text-neutral-gray">Is the word mostly **Good** or mostly **Bad**?</p>
        </header>

        <!-- Engagement Message -->
        <div id="engagementMessageBox" class="absolute top-2 left-1/2 -translate-x-1/2 p-2 bg-yellow-100 text-yellow-800 rounded-lg shadow-md z-10 text-sm">
            Message Placeholder
        </div>

        <!-- Word Card Area -->
        <div class="flex flex-col items-center space-y-4">
            <!-- Left Arrow Indicator (Good) -->
            <div class="left-arrow text-good-green text-lg font-bold cursor-pointer transition duration-150 hover:scale-110">
                &larr; Good
            </div>

            <!-- The main word card element -->
            <div id="wordCard" class="word-card w-full border-4 border-dashed rounded-lg shadow-lg bg-gray-50 text-gray-800">
                <span id="currentWord">Loading...</span>
            </div>

            <!-- Right Arrow Indicator (Bad) -->
            <div class="right-arrow text-bad-red text-lg font-bold cursor-pointer transition duration-150 hover:scale-110">
                Bad &rarr;
            </div>
        </div>
        
        <!-- Action Buttons -->
        <div class="flex justify-between space-x-4">
            <button id="goodWordBtn" class="flex-1 py-3 px-6 bg-good-green text-white font-semibold rounded-lg shadow-md hover:bg-emerald-600 transition duration-150 focus:outline-none focus:ring-4 focus:ring-good-green/50">
                Good Word (&#8592;)
            </button>
            <button id="badWordBtn" class="flex-1 py-3 px-6 bg-bad-red text-white font-semibold rounded-lg shadow-md hover:bg-red-600 transition duration-150 focus:outline-none focus:ring-4 focus:ring-bad-red/50">
                Bad Word (&#8594;)
            </button>
        </div>

        <!-- Leaderboards -->
        <div class="pt-4 border-t border-gray-200">
            <h2 class="text-xl font-bold text-gray-800 mb-4 text-center">Community Ratings</h2>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                
                <!-- Mostly Good List -->
                <div class="bg-green-50 p-4 rounded-lg shadow-inner border border-good-green/50">
                    <h3 class="text-lg font-semibold text-good-green mb-2">Mostly Good</h3>
                    <ul id="mostlyGoodList" class="leaderboard-list text-gray-700">
                        <li>(Loading...)</li>
                    </ul>
                </div>

                <!-- Mostly Bad List -->
                <div class="bg-red-50 p-4 rounded-lg shadow-inner border border-bad-red/50">
                    <h3 class="text-lg font-semibold text-bad-red mb-2">Mostly Bad</h3>
                    <ul id="mostlyBadList" class="leaderboard-list text-gray-700">
                        <li>(Loading...)</li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Version Display (Anchored on the main page structure) -->
        <div id="appVersionDisplay" class="absolute bottom-2 right-4 text-xs text-gray-400"></div>

    </div>

    <script>
        // =======================================================
        // script.js logic embedded here (v1.5.2)
        // =======================================================

        // --- Configuration ---
        const API_BASE_URL = '/api'; 
        const APP_VERSION = '1.5.2'; 
        let currentWordData = null; 
        let isVoting = false; 

        // --- DOM Elements ---
        const appContainer = document.getElementById('appContainer'); 
        let wordCard = document.getElementById('wordCard'); 
        const goodWordBtn = document.getElementById('goodWordBtn');
        const badWordBtn = document.getElementById('badWordBtn');
        const mostlyGoodList = document.getElementById('mostlyGoodList');
        const mostlyBadList = document.getElementById('mostlyBadList');
        const leftArrow = document.querySelector('.left-arrow');
        const rightArrow = document.querySelector('.right-arrow');
        const engagementMessageBox = document.getElementById('engagementMessageBox'); 
        const appVersionDisplay = document.getElementById('appVersionDisplay');


        /**
         * Displays an engagement message briefly.
         * @param {string} message The message text to display.
         */
        function displayEngagementMessage(message) {
            if (message) {
                engagementMessageBox.textContent = message;
                engagementMessageBox.classList.add('visible');

                // Hide the message after 4 seconds
                setTimeout(() => {
                    engagementMessageBox.classList.remove('visible');
                    // Clear text after transition to prevent flicker
                    setTimeout(() => {
                        engagementMessageBox.textContent = '';
                    }, 500); // Matches CSS transition time
                }, 4000);
            }
        }

        async function fetchRandomWord() {
            try {
                // The URL parsing error is often transient, but logging the error helps debug.
                const response = await fetch(`${API_BASE_URL}/get-word`); 
                
                if (response.status === 404) {
                    // Update wordCard reference since it might have been replaced
                    const currentWordSpan = wordCard.querySelector('#currentWord');
                    if (currentWordSpan) currentWordSpan.textContent = "NO MORE WORDS!";
                    wordCard.style.opacity = 0;
                    return null;
                }

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const data = await response.json();
                return data; 
            } catch (error) {
                console.error("Error fetching random word:", error);
                // Update wordCard reference since it might have been replaced
                const currentWordSpan = wordCard.querySelector('#currentWord');
                if (currentWordSpan) currentWordSpan.textContent = "Error loading word :(";
                wordCard.style.opacity = 1; 
                return null;
            }
        }

        async function fetchTopWords() {
            try {
                const response = await fetch(`${API_BASE_URL}/top-words`);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const data = await response.json();
                return data; 
            } catch (error) {
                console.error("Error fetching top words:", error);
                return { mostlyGood: [], mostlyBad: [] };
            }
        }

        async function submitVote(wordId, voteType) { 
            try {
                const response = await fetch(`${API_BASE_URL}/vote`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ wordId, voteType }),
                });
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return await response.json();
            } catch (error) {
                console.error("Error submitting vote:", error);
                return null;
            }
        }

        /**
         * Updates the card with new word data. Performs a destructive replacement 
         * to eliminate all lingering CSS state.
         * @param {object} wordData - The data for the next word.
         */
        function updateWordCard(wordData) {
            return new Promise(resolve => {
                
                // 1. Store the parent node before removal
                const parent = wordCard.parentNode;
                
                // 2. Remove the old card
                wordCard.remove();
                
                if (!wordData || !wordData.word) {
                    // Create a simple text placeholder if no words are left
                    const noWordsElement = document.createElement('div');
                    noWordsElement.textContent = "NO MORE WORDS!";
                    noWordsElement.className = 'word-card w-full border-4 border-dashed rounded-lg shadow-lg bg-gray-50 text-gray-800';
                    noWordsElement.style.opacity = 1;
                    wordCard = noWordsElement;
                    
                    // FIX 1: Insert before the rightArrow element (a direct sibling)
                    parent.insertBefore(noWordsElement, rightArrow); 
                    resolve();
                    return;
                }

                // 3. Create a brand new, clean card element
                const newCard = document.createElement('div');
                newCard.id = 'wordCard';
                newCard.className = 'word-card w-full border-4 border-dashed rounded-lg shadow-lg bg-gray-50 text-gray-800';
                newCard.style.cssText = 'opacity: 1;'; // Start visible and clean
                
                // 4. Create the word span element inside the new card
                const newWordSpan = document.createElement('span');
                newWordSpan.id = 'currentWord';
                newCard.appendChild(newWordSpan);
                
                // 5. Update global reference to the new element
                wordCard = newCard;
                currentWordData = wordData;
                
                // 6. Insert the new card back into the DOM
                // FIX 2: Insert before the rightArrow element (a direct sibling)
                parent.insertBefore(newCard, rightArrow); 
                
                // 7. Update the content
                newWordSpan.textContent = wordData.word;
                
                // 8. Determine border color based on existing votes
                const totalVotes = wordData.goodVotes + wordData.badVotes;
                
                // Remove existing border classes (though a new card shouldn't have them, this is defensive)
                newCard.classList.remove('neutral-border', 'good-border', 'bad-border');

                if (totalVotes === 0) {
                    newCard.classList.add('neutral-border');
                } else {
                    const goodPercentage = (wordData.goodVotes / totalVotes) * 100;
                    if (goodPercentage > 60) {
                        newCard.classList.add('good-border');
                    } else if (goodPercentage < 40) {
                        newCard.classList.add('bad-border');
                    } else {
                        newCard.classList.add('neutral-border');
                    }
                }
                
                resolve(); 
            });
        }

        function renderTopWords(topWords) {
            mostlyGoodList.innerHTML = '';
            mostlyBadList.innerHTML = '';

            topWords.mostlyGood.forEach(word => {
                const li = document.createElement('li');
                const total = word.goodVotes + word.badVotes;
                const percentage = total > 0 
                    ? Math.round((word.goodVotes / total) * 100) 
                    : 0; 

                li.innerHTML = `${word.word} <span class="text-xs font-medium text-good-green">(${percentage}% GOOD)</span>`;
                mostlyGoodList.appendChild(li);
            });

            topWords.mostlyBad.forEach(word => {
                const li = document.createElement('li');
                const total = word.goodVotes + word.badVotes;
                const percentage = total > 0 
                    ? Math.round((word.badVotes / total) * 100) 
                    : 0; 

                li.innerHTML = `${word.word} <span class="text-xs font-medium text-bad-red">(${percentage}% BAD)</span>`;
                mostlyBadList.appendChild(li);
            });
        }

        /**
         * Fetches the next word, updates the card, and updates the leaderboards.
         */
        async function loadCardAndLeaderboard() {
            isVoting = true; 
            
            // Set 'Loading...' text on the existing or new card before destructive replacement
            const currentWordSpan = wordCard.querySelector('#currentWord');
            if (currentWordSpan) {
                currentWordSpan.textContent = 'Loading...';
            }
            
            // 1. Fetch the new word data
            const word = await fetchRandomWord();
            
            // 2. Update the card instantly using the destructive replacement method
            await updateWordCard(word);
            
            // 3. UNLOCK INPUT IMMEDIATELY AFTER CONTENT UPDATE
            isVoting = false; 
            
            // 4. Fetch and render top words in the background
            const topWords = await fetchTopWords();
            renderTopWords(topWords);
        }

        /**
         * Primary function to handle voting via button or arrow.
         * @param {string} voteType 'good' or 'bad'
         */
        async function handleVote(voteType) {
            if (!currentWordData || isVoting) return; 
            isVoting = true; 

            const wordId = currentWordData.word;
            
            // 1. Submit the vote (runs concurrently with the loading state)
            const responseData = await submitVote(wordId, voteType); 

            if (responseData && responseData.engagementMessage) {
                displayEngagementMessage(responseData.engagementMessage);
            }

            // 2. Clear the card content immediately to show 'Loading...' briefly
            const currentWordSpan = wordCard.querySelector('#currentWord');
            if (currentWordSpan) {
                currentWordSpan.textContent = ''; 
            }

            // 3. Load the next card immediately (no setTimeout required)
            await loadCardAndLeaderboard(); 
        }

        /**
         * Sets the version number on a dedicated display element.
         */
        function setAppVersion() {
            if (appVersionDisplay) {
                appVersionDisplay.textContent = `v${APP_VERSION}`;
            }
        }

        // --- Event Listeners ---

        // We must re-add event listeners on the buttons since the buttons themselves are not being replaced.
        goodWordBtn.addEventListener('click', () => handleVote('good'));
        badWordBtn.addEventListener('click', () => handleVote('bad'));

        leftArrow.addEventListener('click', () => handleVote('good'));
        rightArrow.addEventListener('click', () => handleVote('bad'));


        // Keyboard Input (These listeners don't need re-binding as they are on the document)
        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowLeft' && !isVoting) {
                e.preventDefault();
                handleVote('good');
            } else if (e.key === 'ArrowRight' && !isVoting) {
                e.preventDefault();
                handleVote('bad');
            }
        });

        // --- Initial Load ---
        document.addEventListener('DOMContentLoaded', () => {
            setAppVersion();
            loadCardAndLeaderboard();
        });
    </script>
</body>
</html>
