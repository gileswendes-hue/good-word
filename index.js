const express = require('express');
const mongoose = require('mongoose');
const cors = require('cors');
const fs = require('fs'); // Required to read the initial_words.txt file

// --- Configuration & Initialization ---
const app = express();
const PORT = process.env.PORT || 3000;

// IMPORTANT: The MongoDB URI must be set as an environment variable in your Render service settings.
const MONGODB_URI = process.env.MONGODB_URI; 

// Middleware
// Enables CORS so your index.html hosted on one domain can talk to the Render API
app.use(cors()); 
app.use(express.json());

// --- MongoDB Connection and Schema ---

// 1. Define the Mongoose Schema for a Word
const wordSchema = new mongoose.Schema({
    text: { type: String, required: true, unique: true, lowercase: true, trim: true },
    goodVotes: { type: Number, default: 0 },
    badVotes: { type: Number, default: 0 },
    isActive: { type: Boolean, default: true },
    // Store user IDs who have voted to prevent repeat voting
    voters: { type: [String], default: [] }, 
    timestamp: { type: Date, default: Date.now }
});

const Word = mongoose.model('Word', wordSchema);

// 2. Connect to MongoDB and Seed Initial Data
if (!MONGODB_URI) {
    console.error('FATAL ERROR: MONGODB_URI environment variable is not set.');
}

mongoose.connect(MONGODB_URI)
    .then(() => {
        console.log('MongoDB connected successfully.');
        seedInitialWords();
        // Start the server only after a successful database connection
        app.listen(PORT, () => {
            console.log(`Server is running on port ${PORT}`);
        });
    })
    .catch(err => {
        console.error('MongoDB connection error. Please check the MONGODB_URI and IP access list:', err);
    });

/**
 * Seeds the database with a list of words from initial_words.txt if the collection is empty.
 */
async function seedInitialWords() {
    try {
        const count = await Word.countDocuments();
        
        if (count === 0) {
            console.log('Word collection is empty. Reading initial words from file...');

            const filePath = './initial_words.txt';
            
            // Read the words from the separate text file synchronously during startup
            const wordFileContent = fs.readFileSync(filePath, 'utf8');

            // Split by newline, filter out empty/whitespace lines, and map to Mongoose objects
            const initialWords = wordFileContent
                .split('\n')
                .map(word => word.trim())
                .filter(word => word.length > 0)
                .map(text => ({
                    text: text.toLowerCase(),
                    goodVotes: 0, 
                    badVotes: 0
                }));

            if (initialWords.length > 0) {
                await Word.insertMany(initialWords);
                console.log(`Successfully seeded ${initialWords.length} initial words.`);
            } else {
                console.log('initial_words.txt was empty. Database remains empty.');
            }
        } else {
            console.log(`Word collection already contains ${count} words. Skipping seeding.`);
        }
    } catch (error) {
        // Catches file-reading errors (e.g., file not found) or database errors
        console.error("Error during initial seeding (ensure initial_words.txt is in the root directory):", error.message);
    }
}

// --- API ROUTES ---

// 1. GET /api/words - Fetch all words for game state and rankings
app.get('/api/words', async (req, res) => {
    try {
        // Fetch only active words and sort by timestamp (order of insertion)
        const words = await Word.find({ isActive: true }).sort({ timestamp: 1 });
        res.json(words); 
    } catch (err) {
        console.error("Error fetching words:", err);
        res.status(500).json({ message: 'Failed to fetch words' });
    }
});

// 2. POST /api/words - Submit a new custom word
app.post('/api/words', async (req, res) => {
    const { text } = req.body;

    if (!text || text.length < 2 || text.includes(' ')) {
        return res.status(400).json({ message: 'Word must be 2+ characters and contain no spaces.' });
    }

    try {
        const newWord = new Word({ text: text.toLowerCase() });
        await newWord.save();
        res.status(201).json(newWord);
    } catch (err) {
        // Handle duplicate key error (word already exists)
        if (err.code === 11000) {
            return res.status(409).json({ message: `The word "${text}" is already submitted.` });
        }
        console.error("Error submitting word:", err);
        res.status(500).json({ message: 'Failed to submit word.' });
    }
});

// 3. PUT /api/words/:wordId/vote - Register a vote
app.put('/api/words/:wordId/vote', async (req, res) => {
    const { wordId } = req.params;
    // Get vote type and the unique user ID generated by the front-end
    const { voteType, userId } = req.body; 

    if (!['good', 'bad'].includes(voteType) || !userId) {
        return res.status(400).json({ message: 'Invalid vote data.' });
    }

    try {
        const word = await Word.findById(wordId);

        if (!word) {
            return res.status(404).json({ message: 'Word not found.' });
        }

        // Check if the user ID is already in the voters array to enforce one vote per user per word
        if (word.voters.includes(userId)) {
            return res.status(403).json({ message: 'User already voted on this word.' });
        }

        const updateField = voteType === 'good' ? 'goodVotes' : 'badVotes';
        
        // Atomically increment the vote count and add the userId to prevent race conditions
        const result = await Word.findByIdAndUpdate(wordId, {
            $inc: { [updateField]: 1 },
            $push: { voters: userId }
        }, { new: true }); 

        res.json({ message: 'Vote registered successfully', word: result });

    } catch (err) {
        console.error("Error processing vote:", err);
        res.status(500).json({ message: 'Failed to register vote.' });
    }
});
